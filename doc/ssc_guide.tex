\documentclass{article}
\usepackage{geometry} 
\geometry{letterpaper} 
%%%% Uncomment below to begin paragraphs with an empty line %%%%
\usepackage[parfill]{parskip} 
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{moreverb}
%\usepackage[section]{placeins}
%\usepackage[below]{placeins}
\usepackage{epstopdf}

% Begin from doxygen
%\usepackage{makeidx}
%\usepackage{natbib}
\usepackage{graphicx}
%\usepackage{multicol}
\usepackage{float}
%\usepackage[table]{xcolor}
\usepackage{listings}
\usepackage{color}
%\usepackage{ifthen}
\usepackage{textcomp}
\usepackage{alltt}
\usepackage{pspicture}
%\fi
%\usepackage[utf8]{inputenc}
\usepackage{mathptmx}
%\usepackage[scaled=.90]{helvet}
%\usepackage{courier}
%\usepackage{sectsty}
%\usepackage[titles]{tocloft}
\usepackage{doxygen}
\usepackage[pdftex,
                  linktocpage=true,
                  pagebackref=true,
                  colorlinks=true,
                  linkcolor=blue,
                  unicode
                ]{hyperref}

\lstset{language=C++,inputencoding=utf8,basicstyle=\footnotesize,breaklines=true,breakatwhitespace=true,tabsize=8,numbers=left }
%\makeindex
%\renewcommand{\footrulewidth}{0.4pt}
%\renewcommand{\familydefault}{\sfdefault}
%\hfuzz=15pt
%\setlength{\emergencystretch}{15pt}
%\hbadness=750
% End from doxygen

%\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\newcommand\bslash{\char`\\}
\newcommand\lt{\char`\<}
\newcommand\gt{\char`\>}
\newcommand{\tab}{\hspace*{2em}}
\newcommand{\supers}[1]{\ensuremath{^\textrm{{\scriptsize #1}}}}
\newcommand{\subs}[1]{\ensuremath{_\textrm{{\scriptsize #1}}}}
\newcommand{\notebox}[1]{ \begin{center}\framebox[5.5in]{\begin{minipage}[t]{5.0in}\textbf{Note: }#1\end{minipage}}\end{center}}

\title{SSC Reference Manual}
\author{Aron P. Dobos}

\begin{document}

\maketitle
\vspace{3in}
\begin{abstract}
The SSC (SAM Simulation Core) software library implements the underlying renewable energy system modeling calculation engine utilitized by the popular desktop System Advisor Model (SAM) tool.  SSC provides a simple and programmer-friendly application programming interface (API) that allows developers to directly integrate SAM calculations into other tools.  The API includes mechanisms to set input variable values, run simulations, and retrieve calculated outputs.  The library is provided to users as pre-compiled binary dynamic libraries for Windows, Mac OSX, and Linux, with the bare minimum system library dependencies.  While the native API language is ISO-standard C, language bindings for MATLAB, and Python are included.  The API and model implementations are thread-safe and reentrant, allowing the software to be efficiently utilized in a parallel computing environment.

This document describes the software architecture of SSC, introduces the SSC Development Environment tool, explains how to set up simulations from code, query the library for variable information, and provides examples and ``case studies" in various programming languages to ease the adoption of SSC into other systems.  

\textbf{Note.} The reader is assumed to have familiarity with the C programming language, as well as some level of proficiency using the System Advisor Model (SAM) tool.
\end{abstract} 

\newpage
\tableofcontents
%%\listoffigures
%%\listoftables
\newpage

\section{Overview}
\label{sec_overview}

The SSC software development kit (SDK) provides tools for creating models of renewable energy systems using the SSC library. The System Advisor Model (SAM) desktop application is a user-friendly front-end for the SSC library that uses SSC modules to perform all system performance and financial calculations. This manual assumes that the reader is familiar with SAM's suite of performance and financial models, input and output variables, and other capabilities. The SDK consists of the application programming interface (API), library, programming language wrappers, integrated development environment, and code samples.

\subsection{Framework Description}

The SSC framework provides a generic mechanism for running modules, setting values of module inputs, and reading values of module outputs. The mechanisms are generic because they do not depend on the module. For example, the same mechanism provides access to the PVWatts (\texttt{pvwattsv1}) and Utility IPP ( \texttt{ippppa}) modules.  

Using an SSC module is analogous to calling a function in a programming language: You pass parameter values to the function, run the function, and then read values returned by the function.  In SSC, you store input variables in a data container, run the module, and retrieve outputs from the data container:

\begin{enumerate}
\item Create a data container of type \texttt{ssc\_data\_t} for model input variables.
\item Call a simulation module such as \texttt{pvwattsv1} or \texttt{ippppa} of type \texttt{ssc\_module\_t} to process variables in the data container. If the module runs successfully, it populates the data container with output variables. If it fails, it generates error messages.
\item Retrieve output variable values from the data container, or error messages from the module.
\end{enumerate}

\subsection{Modeling an Energy System}
\label{sec_modeling_systems}
The SSC modules process weather data files, simulate energy system component performance, and calculate project cash flows. Table~\ref{tab_sample_modules} lists some of the SSC modules.\marginpar{For a complete list, see?}

\begin{table}[ht]
\begin{center}
\begin{tabular}{ll}
Module & Description \\
\hline
\texttt{pvwattsv1} & Implements the NREL PVWatts model for PV performance\\
\texttt{pvsamv1} & Implements the component-based PV models in SAM\\
\texttt{wfreader} & Reads standard format weather data files (TM2, TM3, EPW, SMW)\\
\texttt{irradproc} & General purpose irradiance processor for calculating POA\\
\texttt{windpower} & Implements the NREL wind turbine and simple wind farm model\\
\texttt{cashloan} & Implements residential and commercial cashflow economic model\\
\texttt{ippppa} & Commercial PPA and Independent Power Producer (IPP) financial models\\
\texttt{annualoutput} & Calculates degraded out-years system output for the analysis period\\
\texttt{utilityrate} & Calculates the value of energy using complex utility rate structures\\
\end{tabular}
\caption{Some commonly used SSC modules}
\label{tab_sample_modules}
\end{center}
\end{table}

Creating a technical model of a renewable energy system or a technoeconomic model of a renewable energy project in SSC involves choosing a set of modules. For example, a model of a residential photovoltaic project might use the following modules:\marginpar{Would this example require a weather reader too?}

\begin{enumerate}
\item \texttt{pvwattsv1}: The system parameters are used to calculate the hourly PV system performance.
\item \texttt{annualoutput}: The availability and degradation factors are applied to the annual energy output for the duration of the specified analysis period.
\item \texttt{utilityrate}: The value of the generated energy is calculated given the specifics of the complex utility rate structure, and the first year's hourly energy value is reported, along with the annual total value of energy at each year of the analysis period.
\item \texttt{cashloan}: Given the amount of the energy produced each year and the dollar value of this energy, this module calculates the cost of energy, net present value, and other metrics of the system based on specified system cost, incentives, operation and maintainance costs, taxes, and loan parameters.
\end{enumerate}

In this example, the modules would run in the order shown above, with outputs of each module serving as inputs for the next. Because the modules do not necessarily use the same names or units for variables representing the same quantities, lines of code in the program calling the modules may be required to translate values.  For example, the \texttt{pvwattsv1} module has an output variable \texttt{ac} which is the hourly energy in kWh produced by the system, while the \texttt{annualoutput} module requires an input with the name \texttt{energy\_net\_hourly}./marginpar{Must all modules use the same data container, or can you set up a separate container for each module?}  It is up to the user to ensure that variables are translated appropriately between the outputs of one module and the inputs of another, including any units conversions that may be necessary.  Luckily, SSC provides exhaustive documentation of all of the input variables required by a module and all of the outputs that will be calculated.  Working with input and output variables will be the topic of a subsequent chapter./marginpar{Where is the documentation of input and output variables?}

\section{A Basic Example: PVWatts}

In this section, we will write a simple command-line C program to calculate the monthly energy production of a 1 kW PV system at a particular location.  The complete source code for this example program is included with the SSC SDK in the file \texttt{example1\_pvwatts.c}.

\subsection{Program Skeleton}

The SSC API is defined a C header called \texttt{sscapi.h}, and this file must be included in your program before any SSC functions can be called.  We will assume that the weather file is specified as a command line argument, and is one of the types that the \texttt{pvwattsv1} can read (TM2, TM3, EPW, SMW).  The skeleton of our program might look like the listing below.

\begin{verbatimtab}[4]
#include <stdio.h>
#include "sscapi.h"

int main(int argc, char *argv[])
{
	if ( argc < 2 )
	{
		printf("usage: pvwatts.exe <weather-file>\n");
		return -1;
	}
 
	// run PVWatts simulation for the specified weather file
	
	return 0;
}
\end{verbatimtab}

\subsection{Setting up data inputs}

Now we will fill in the comment in the middle of the code step-by-step.  Referring to the three step process outlined in Section~\ref{sec_overview}, the first task is to create a data container.  This is done with the \texttt{ssc\_data\_create()} function call, which returns an \texttt{ssc\_data\_t} type.  If for some reason the function call fails due to the system having run out of memory, \texttt{NULL} will be returned.  It is important to check the result to make sure the data container was created successfully.

\begin{verbatimtab}[4]
	ssc_data_t data = ssc_data_create();
	if ( data == NULL )
	{
		printf("error: out of memory.\n");
		return -1;
	}
\end{verbatimtab}

Next, we assign the input variables required by the \texttt{pvwattsv1} module.  In \S\ref{chap_variables}, we will show how to obtain information about the data types, names, labels, and units of variables.  For now, it suffices to say that SSC supports data as numbers, text strings, arrays, matrices, and tables.

\begin{verbatimtab}[4]
	ssc_data_set_string( data, "file_name", argv[1] ); // set the weather file name
	ssc_data_set_number( data, "system_size", 1.0f );  // system size of 1 kW DC
	ssc_data_set_number( data, "derate", 0.77f );      // system derate
	ssc_data_set_number( data, "track_mode", 0 );      // fixed tilt system
	ssc_data_set_number( data, "tilt", 20 );           // 20 degree tilt
	ssc_data_set_number( data, "azimuth", 180 );       // south facing (180 degrees)
\end{verbatimtab}

At this point, we have a data container with six variables that are the input parameters to the module that we wish to run.  

\subsection{Simulating and retrieving outputs}
\label{sec_ex_pvwatts_module}

Next, an instance of the module itself must be created, per below.  The name of the desired module must be passed to the \texttt{ssc\_module\_create()} function.  If the specified module name is not recognized, or the system is out of memory, the function may return \texttt{NULL}.

\begin{verbatimtab}[4]
	ssc_module_t module = ssc_module_create( "pvwattsv1" );
	if ( NULL == module )
	{
		printf("error: could not create 'pvwattsv1' module.\n");
		ssc_data_free( data );
		return -1;
	}
\end{verbatimtab}

Next, the simulation must be run.  If all the required input variables have been defined in the data container and have appropriate data types and values, the simulation should finish successfully.  Otherwise, an error will be flagged.  

\begin{verbatimtab}[4]
	if ( ssc_module_exec( module, data ) == 0 )
	{
		printf("error during simulation.\n");
		ssc_module_free( module );
		ssc_data_free( data );
		return -1;
	}
\end{verbatimtab}

By default, the \texttt{ssc\_module\_exec()} function prints any log or error messages to standard output on the console.  There is a more complex way to run a simulation that can reroute messages somewhere else, for example if a program wanted to pop up a message box or collect all messages and return them to the sure.  This will be discussed in later sections.

Assuming that the simulation succeeded, it is now time to extract the calculated results.  Modules may calculate hundreds of outputs, but for this example, we simply are interested in the total AC energy produced by the 1 kW PV system.  As it turns out, \texttt{pvwattsv1} only provides the hourly data, so it is up to us to sum up the hourly values.  The code snippet below shows how to query the data object for the \texttt{ac} variable and aggregate it.

\begin{verbatimtab}[4]
	double ac_total = 0;
	int len = 0;
	ssc_number_t *ac = ssc_data_get_array( data, "ac", &len );
	if ( ac != NULL )
	{
		int i;
		for ( i=0; i<len; i++ )
			ac_total += ac[i];
		printf("ac: %lg kWh\n", ac_total*0.001 );
	}
	else
	{
		printf("variable 'ac' not found.\n");
	}
\end{verbatimtab}

\subsection{Cleaning up}

We're now finished simulating the PV system and retrieving the results.  To avoid filling up the computer's memory with unneeded data objects, it is important to free the memory when it is no longer needed.  To this end, the \texttt{ssc\_module\_free()} and \texttt{ssc\_data\_free()} functions are provided.  Note that after calling one of these functions, the \texttt{module} and \texttt{data} variables are invalidated and cannot be used unless reassigned to another or a new data object or module.

\begin{verbatimtab}	
	ssc_module_free( module );
	ssc_data_free( data );
\end{verbatimtab}

\subsection{Compiling and running}

Using the MinGW compiler toolchain on Windows, it is very straightforward to compile and run this example.  Simply issue the command below at the Windows command prompt (\texttt{cmd.exe} from Start/Run), assuming that the \texttt{sscapi.h} header file and 32-bit \texttt{ssc.dll} dynamic library is in the same folder as the source file.  The complete source code for this example is included in the SSC SDK.  This example was tested with MinGW gcc version 4.6.2.

\begin{verbatim}
c:\> gcc example1_pvwatts.c ssc.dll -o pvwatts.exe
\end{verbatim}

To run the program, specify a weather file on the command-line.  Here, we use TMY2 data for Daggett, CA, which is included in the SDK as \emph{daggett.tm2}.

\begin{verbatim}
c:\> pvwatts.exe daggett.tm2
ac: 1468.54 kWh
\end{verbatim}

If all goes well, the total annual AC kWh for the system is printed on the console.


\subsection{Some additional comments}

The \texttt{ssc\_data\_t} and \texttt{ssc\_module\_t} data types are opaque references to internally defined data structures.  The only proper way to interact with variables of these types is using the defined SSC function calls.  As listed in the \texttt{sscapi.h} header file, both are typedef'd as \texttt{void*}.


\section{Data Variables}
\label{sec_variables}

Simulation model inputs and outputs are stored in a data container of type \texttt{ssc\_data\_t}, which is simply a collection of named variables.  Internally, the data structure is an unordered map (hash table), permitted very fast lookup of variables by name.  Every input and output variable in SSC is designated a name, a \emph{variable type}, and a \emph{data type}, along with other meta data (labels, units, etc). 

The variable name is mechanism by which data are identified by SSC, and the user is required to supply input variables with names that SSC has predefined.  Names can contain letters, numbers, and underscores.  Although names can be defined with upper and lower case letters, SSC does not distinguish between them internally: hence \texttt{Beam\_Irradiance} is the same variable as \texttt{beam\_irradiance}.

\subsection{Variable Types}

The \emph{variable type} identifies each variable as an input, output, or in-out variable.  In the SSC API, these values are defined by the constants reproduced below.

\begin{verbatimtab}
#define SSC_INPUT 1
#define SSC_OUTPUT 2
#define SSC_INOUT 3
\end{verbatimtab}

Input variables are required to be set by the user before a module is called, while output variables are calculated by the module and assigned to the data container when the module has finished running.  In-out variables are supplied by the user before the model runs, and the model transforms the value in some fashion.

Note that from the perspective of the data container, inputs and outputs are stored without distinction in an equivalent manner.  Thus, it is impossible to tell simply from the contents of a data container whether a variable was an input or an output - it is just a pile of data.  It is only the simulation modules that specify the variable type.

\subsection{Data Types}

Every variable in SSC is assigned a particular data type, and each simulation module to specifies the data type of each variable required as input, as well as the data type of each output.  SSC can work with numbers, text strings, one-dimensional arrays, two-dimensional matrices, and tables.  The data type constants are listed below.

\begin{verbatimtab}
#define SSC_INVALID 0
#define SSC_STRING 1
#define SSC_NUMBER 2
#define SSC_ARRAY 3
#define SSC_MATRIX 4
#define SSC_TABLE 5
\end{verbatimtab}

All numbers are stored using the \texttt{ssc\_number\_t} data type.  By default, this is a typedef of the 32-bit floating point C data type (\texttt{float}).  The purpose of using \texttt{float} instead of the 64-bit \texttt{double} is to save memory.  While a simulation module may perform all of its calculations internally using 64-bit precision floating point, the inputs and results are transferred into and out of SSC using the smaller data type.

Arrays (1-D) and matrices (2-D) store numbers only - there is no provision for arrays or matrices of text strings, or arrays of tables.  Arrays and matrices are optimized for efficient storage and transfer of large amounts of numerical data.  For example, a photovoltaic system simulation at 1 second timesteps for a whole year would produce 525,600 data points, and potentially several such data vectors might be reported by a single simulation model.  This fact underscores the reasoning to use the 32-bit floating point data type: just 20 vectors of 525,600 values each would require 42 megabytes of computer memory.

SSC does not provision separate storage for integers and floating point values - all numbers are stored internally as floating point.  However, a module may specific a numeric input with the \emph{integer} constraint which is checked automatically before the module is run.  Constraints will be discussed later.

Text strings (\texttt{SSC\_STRING})  are stored as 8-bit characters.  SSC does not support multi-byte or wide-character string representations, and all variable names and labels use only the 7-bit ASCII Latin alphabet.  Consequently, text is stored as null ('\textbackslash 0') terminated \texttt{char*} C strings.  Weather file names are common input variables that use the \texttt{SSC\_STRING} data type.

The table (\texttt{SSC\_TABLE}) data type is the only hierarchical data type in SSC.  Essentially, it allows a simulation module to receive or return outputs in a structured format with named fields.  A table is nothing more than a named variable that is itself a data container, which can store any number of named variables of any SSC data type.  Currently, most SSC modules do not make heavy use of tables, but they are fully implemented and supported for future complex modules that may be added.

\subsection{Variable Documentation}

As stated before, each module defines all of the input variables it requires and output variables it produces.  Since SSC is a model simulation framework that contains within it numerous calculation modules that each may have hundreds of variables, it is impractical to separate to the documentation of variables from their definitions.  Otherwise, the documentation would tend to be consistently out of date as modules are updated and new ones are added.
\begin{table}[ht]
\begin{center}
\begin{tabular}{ll}
Field & Description\\
\hline
Variable type & \texttt{SSC\_INPUT}, \texttt{SSC\_OUTPUT}, \texttt{SSC\_INOUT} \\
Data type & \texttt{SSC\_NUMBER}, \texttt{SSC\_STRING}, \texttt{SSC\_ARRAY}, \texttt{SSC\_MATRIX}, \texttt{SSC\_TABLE} \\
Name & Variable name (case insensitive) \\
Label & A description of the variable's purpose \\
Units & The units of the numerical value(s) \\
Meta & Additional information. Could specify encoding of values, see below. \\
Group & General category of variable, e.g. ``Weather'', ``System Input'' \\
Required & Specifies whether the variable must be assigned a value. See \S\ref{sec_def_const} \\
Constraints & Constraints on the values or number of values. See \S\ref{sec_def_const} \\
UI Hints & Suggestions on how to display this variable.  Currently unused. \\
\end{tabular}
\caption{Variable information provided by SSC}
\label{tab_varinfo}
\end{center}
\end{table}

Consequently, SSC provides functions in the API to return information about all of the variables defined by a module.  Each variable specifies the information shown in Table~\ref{tab_varinfo}.


To obtain information for a variable, a module is queried using the \texttt{ssc\_module\_var\_info()} function, which returns a \texttt{ssc\_info\_t} reference.  The \texttt{ssc\_module\_var\_info()} function is called repeatedly with an index variable that is incremented by the user to cycle through all of the variables defined by the module.  An example is shown below, assuming that the variable \texttt{module} has been successfully created for a particular simulation module (e.g., see \S\ref{sec_ex_pvwatts_module}).  Querying SSC for available modules is discussed in \S\ref{sec_modules_querying}.

\begin{verbatimtab}[4]
int i=0;
ssc_info_t p_inf = NULL;
while ( p_inf = ssc_module_var_info( module, i++ ) )
{
	// var_type: SSC_INPUT, SSC_OUTPUT, SSC_INOUT
	int var_type = ssc_info_var_type( p_inf );

	// data_type: SSC_STRING, SSC_NUMBER, SSC_ARRAY, SSC_MATRIX, SSC_TABLE   
	int data_type = ssc_info_data_type( p_inf );
      
	const char *name = ssc_info_name( p_inf );
	const char *label = ssc_info_label( p_inf );
	const char *units = ssc_info_units( p_inf );
	const char *meta = ssc_info_meta( p_inf );
	const char *group = ssc_info_group( p_inf );
	const char *required = ssc_info_required( p_inf );
	const char *constraints = ssc_info_constrants( p_inf );

	// here, you can print all of this data to text file
	// or present it in another way to the user

	printf( "%s %s (%s) %s\n", name, label, units, meta );
}

\end{verbatimtab}

The interactive SSCdev tool provided with the SSC library automatically generates all of this documentation for all modules in an interactive GUI spreadsheet-style interface.  This utility will be discussed in more detail in \S\ref{sec_sscdev_vars}.

\subsection{Default Values and Constraints}
\label{sec_def_const}

Sometimes there are so many input variables for a module that SSC assigns reasonable default values for some of the inputs if they are not explicitly specified by the user.  In other cases, some inputs may only have relevance for advanced users, and so a standard default value is provided that is recommended for the majority of simulations.  If a default value is provided, it is specified in the \emph{required} field of the variable information table.

If the \emph{required} field contains \texttt{``*''}, this means that there is no default value and the user must specify one in all cases.  If the \emph{required} field begins with the character \texttt{``?''}, it means that the variable is optional, and that SSC will use the value assigned by the user if it is provided.  The manner in which an optional variable affects the calculation is specific to each module, and so cannot be expanded upon here.

A default value is provided by SSC if the \emph{required} field appears as \texttt{``?=<value>''}, where \texttt{<value>} may be a number, a text string, or comma-separated array, depending on the data type of the variable.  In effect, this means that the variable always be given a value before simulation, but the user need not specify it.  For example, the \texttt{pvwattsv1} module specifies \texttt{rotlim} (tracker rotation limit) variable's \emph{required} field as \texttt{``?=45.0''}, meaning that unless the user specifies a different value, a rotation limit of 45 degrees is used.

In addition to providing some default values, SSC performs some data input validation before running a simulation using the \emph{constraints} field.  This field may optionally define any number of flags recognized by SSC that may limit the valid range of a numeric input variable, or define the required length of an input array.  A selection of the flags used by SSC is listed in Table~\ref{tab_constraints}.  Note that these flags are defined internally by the modules, and are not editable by users.  Also, in the case that the \emph{constraints} field is empty, that does not necessarily imply that any values are acceptable - the module writer may have inadvertently omitted a constraint flag, and may instead manually check each variable when the module runs.

\begin{table}[ht]
\begin{center}
\begin{tabular}{ll}
Flag & Description\\
\hline
\texttt{MIN=<value>} & Specifies the minimum permissible value for a number \\
\texttt{MAX=<value>} & Specifies the maximum permissible value for a number \\
\texttt{BOOLEAN} & Requires the number to be equal to 0 (false) or 1 (true) \\
\texttt{INTEGER} & Requires the number to be an integer value \\
\texttt{POSITIVE} & Requires the number to have a positive, non-zero value \\
\texttt{LOCAL\_FILE} & Requires the text string to be a local file on disk that is readable and exists \\
\end{tabular}
\caption{Some constraints recognized by SSC}
\label{tab_constraints}
\end{center}
\end{table}

Constraints can be combined to further restrict the value of a number.  For example, in \texttt{pvwattsv1}, the \texttt{track\_mode} variable's constraints field is \texttt{``MIN=0,MAX=3,INTEGER''}.  This specification limits the possible values of the variable to 0, 1, 2, or 3, which are the numeric values associated with a fixed, 1-axis, 2-axis, or azimuth-axis tracking PV system.

\subsection{Manipulating Data Containers}
\label{sec_data_manip}

As was shown in the initial PVWatts example, a data container is created and freed using the \texttt{ssc\_data\_first()} and \texttt{ssc\_data\_next()} functions.  Here, some additional functions for working with data containers are explored.

The \texttt{ssc\_data\_unassign()} function removes a variable from the container, releasing any memory associated with it.  To erase all of the variables in a container and leave it empty (essentially resetting it), use the \texttt{ssc\_data\_clear()} function.  For example:

\begin{verbatimtab}
ssc_data_unassign( data, "tilt" ); // remove the 'tilt' variable

ssc_data_clear( data ); // reset the container by erasing all the variables
\end{verbatimtab}


To find out the names of all variables in a container, functions \texttt{ssc\_data\_first()} and \texttt{ssc\_data\_next()} are used.  These functions return the name of a variable, or \texttt{NULL} if there are no more variables in the container.  The \texttt{ssc\_data\_query()} function returns the data type of the specified variable, which is useful for subsequently retrieving its value.  The example below prints out the text of all the string variables in a data container:

\begin{verbatimtab}[4]
const char *name = ssc_data_first( data );
while( name != 0 )
{
	// do something, like query the data type
	int type = ssc_data_query( data, name );

	if ( type == SSC_STRING )
	{
		const char *text = ssc_data_get_string( data, name );
		printf("string variable %s: %s\n", name, text );
	}

	name = ssc_data_next( data );
}
\end{verbatimtab}

See the API reference in \S\ref{sec_api_ref} for detailed documentation of each function's parameters and return values.

\subsection{Assigning and Retrieving Values}

This section discusses the particulars of assigning and retrieving variable values.  Note that assigning a variable that already exists in the container causes the old value to be erased.

\subsubsection{Numbers}

Numbers are transferred and stored using the \texttt{ssc\_number\_t} data type.  To assign a value:

\begin{verbatim}
ssc_data_set_number( data, "track_mode", 2 ); // integer value
ssc_data_set_number( data, "tilt", 30.5f ); // floating point value

ssc_number_t azimuth = 182.3f;
ssc_data_set_number( data, "azimuth", azimuth ); // from a variable
\end{verbatim}

To retrieve a numeric value, it must be declared first, since the retrieval function returns true or false.  False is returned if the specified variable does not exist in the data container.

\begin{verbatimtab}[4]
ssc_number_t value;
if( ssc_data_get_number( data, "tilt", &value ) )
	printf( "tilt = %f\n", value );
else
	printf( "not found\n" );
\end{verbatimtab}

\subsubsection{Arrays}

Arrays are passed to SSC using standard C arrays (pointers), along with the length of the array. Examples:

\begin{verbatimtab}
ssc_number_t monthdays[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
ssc_data_set_array( data, "nday", monthdays, 12 );

// dynamically allocate an array of size len
ssc_number_t *xx = (ssc_number_t*) malloc( sizeof(ssc_number_t)*len );
for( i=0; i<len; i++ ) xx[i] = i*i;

ssc_data_set_array( data, "isquared", xx, len );

free( xx ); // SSC does not take ownership, so free any arrays here.
\end{verbatimtab}

\notebox{When assigning an array, SSC makes an internal copy, and does not take ownership of the array passed in.  Thus it is up to the user to deallocate any memory created in the client code as appropriate.}

Array data is retrieved from SSC using the \texttt{ssc\_data\_get\_array()} function.  The length of the retrieved array is returned in the length reference parameter.  If the requested variable is not assigned, or is not an \texttt{SSC\_ARRAY}, \texttt{NULL} is returned.  Example:

\begin{verbatimtab}[4]
int len = 0;
const ssc_number_t *array = ssc_data_get_array( data, "xx", &len );

if( array != NULL && len > 0 )
{
	printf("len: %d, first item=%f\n", len, array[0] );
}
\end{verbatimtab}

\notebox{The \texttt{ssc\_data\_get\_array()} returns a reference to internally managed memory: do not deallocate or otherwise change the array returned by it.  This is done to improve efficiency when working with large data vectors.}

\subsubsection{Matrices}

Matrices are two dimensional arrays of numbers.  In SSC, matrices are stored as one contiguous array, in row-major order.  Like arrays, they consist of \texttt{ssc\_number\_t} data and are passed to SSC using standard C arrays, along with the number of rows and columns.

Row-major ordering means that the two dimensional array is flattened into a single dimensional vector.  In a 4x3 matrix, the flattened vector will have 12 values in which indices [0..3] represent the first row, [4..7] the second row, and [8..11] the third row.  Example:

\begin{verbatimtab}[4]
ssc_number_t mat[12] = { 4,4,5,1,
                         6,7,2,5,
                         1,6,2,3 };

ssc_data_set_matrix( data, "mat1", mat, 4, 3 );
\end{verbatimtab}

\notebox{SSC creates an internal copy of the matrix passed to \texttt{ssc\_data\_set\_matrix()}.  If the matrix was allocated dyamically, it is up to the user written client code to deallocate it properly: SSC does not take ownership.}

Matrices are returned in the same format.  If the requested variable does not exist or is not a matrix, \texttt{NULL} is returned.  Example:

\begin{verbatimtab}[4]
int nrows, ncols;
ssc_number_t *mat = ssc_data_get_matrix( data, "mat1", &nrows, &ncols );

if( mat != NULL && nrows == 4 && ncols == 3 )
{
	int r, c, index = 0;
	for( r=0; r<nrows; r++ )
		for( c=0; c<ncols; c++ )
			printf( "mat[%d,%d]=%f\n", r, c, mat[index++] );
}
\end{verbatimtab}
\notebox{The \texttt{ssc\_data\_get\_matrix()} returns a reference to internally managed memory: do not deallocate or otherwise change the array returned by it.}

\subsubsection{Strings}

SSC supports null-terminated ASCII text strings as a data type.  Setting a string value is straightforward.  SSC creates an internal copy of the string data.  Examples:
\begin{verbatimtab}
ssc_data_set_string( data, "weather_file", "c:/Data/Weather/TX Abilene.tm2" );

const char *location = "Hawaii";
ssc_data_set_string( data, "location", location );
\end{verbatimtab}

Retrieving strings is similarly straightforward:

\begin{verbatimtab}[4]
const char *location = ssc_data_get_string( data, "location" );
if( location != NULL )
	printf("location = %s\n", location );
\end{verbatimtab}

\notebox{Do not free or modify the pointer returned by \texttt{ssc\_data\_get\_string()}.  A reference to an internally managed character byte array is returned.}

\subsubsection{Tables}

Tables provide a way to communicate data to SSC in a hierarchical structure format.  This data type is provisioned for future simulation modules, but current ones do not use this data type.  Nonetheless, the SSCdev utility (\S\ref{sec_sscdev}) fully supports tables.  Before a table can be assigned, it must be created and filled with variables.  A table is simply a normal data container.  Example:

\begin{verbatimtab}
ssc_data_t table = ssc_data_create(); // create an empty table
ssc_data_set_string( table, "first", "peter" );
ssc_data_set_string( table, "last", "jones" );
ssc_data_set_number( table, "age", 24 );

ssc_data_set_table( data, "person", table ); // assign the table

ssc_data_free( table ); // free the table after it is assigned
\end{verbatimtab}

Since a table is a just an \texttt{ssc\_data\_t} object, it can store any SSC data type, including another table.  This structure allows for nested tables, as potentially needed by a future complicated simulation module.

\notebox{SSC creates an internal copy of the table and all of its variables.  As such, the table should be deallocated after it is assigned, per the example above.}

Retrieving a table is a straightforward operation:

\begin{verbatimtab}[4]
ssc_data_t table = ssc_data_get_table( data, "person" );
if( table != NULL )
{
	printf( "person.first = %s\n", ssc_data_get_string( table, "first" ) );
	printf( "person.last = %s\n", ssc_data_get_string( table, "last" ) );
}
// do not free the 'table' variable: it is internal to SSC
\end{verbatimtab}

\notebox{The \texttt{ssc\_data\_get\_table()} function returns an internal reference to a data container.  Do not deallocate or otherwise modify the returned reference.}

Note that the \texttt{ssc\_data\_first()} and \texttt{ssc\_data\_next()} functions described in \S\ref{sec_data_manip} can be used to determine all of the fields of a table.


\section{Simulation Modules}
\label{sec_modules}

The SSC framework exposes several different simulation modules that calculate outputs given inputs.  Each module can run independently of all the others, provided that all the input variables that are required are provided by the user.  The System Advisor Model (SAM) tool often runs several SSC modules in succession to simulate the whole system performance and economic evaluation.  In between successive calls to different SSC modules, SAM may change the names or scale the output variables of one module to set it up with appropriate inputs for the next one, as explained in \S\ref{sec_modeling_systems}.

\subsection{Querying SSC for Available Modules}
\label{sec_modules_querying}

SSC provides a programming interface by which the library can be queried about all of the modules contained within it.  The example below prints all of the available modules to the console along with their version numbers and descriptions:

\begin{verbatimtab}[4]
ssc_entry_t entry;
int index = 0;
while( entry = ssc_module_entry( index++ ) )
{
	const char *module_name = ssc_entry_name( entry );
	const char *description = ssc_entry_desc( entry );
	int version = ssc_entry_version( entry );

	printf( "Module %s, version %d: %s\n", module_name, version, description );
}
\end{verbatimtab}

\subsection{Simple Method \#1}

A simulation module can be invoked in one of several ways.  The simplest way to call a module is to use the \texttt{ssc\_module\_exec\_simple()} function.  This method prints any warnings or errors to the console, and simply returns true or false. The PVWatts example from earlier could be written as:

\begin{verbatimtab}[4]
ssc_data_t data = ssc_data_create();
ssc_data_set_string( data, "file_name", "TX Abilene.tm2" );
ssc_data_set_number( data, "system_size", 4 );
ssc_data_set_number( data, "derate", 0.77f );
ssc_data_set_number( data, "track_mode", 0 );
ssc_data_set_number( data, "tilt", 20 );
ssc_data_set_number( data, "azimuth", 180 );

if( ssc_module_exec_simple( "pvwattsv1", data ) )
{
	int i, len;
	ssc_number_t ac_sum = 0;
	ssc_number_t *ac = ssc_data_get_array( data, "ac", &len );
	for( i=0;i<len;i++ ) ac_sum += ac[i];
	printf( "success, ac: %f Wh\n", ac_sum );

}
else
	printf( "an error occured\n" );

ssc_data_free( data );
\end{verbatimtab}

Note that there is no need to explicitly create an \texttt{ssc\_module\_t} object using \texttt{ssc\_module\_create()}; the function will return false if the module name specified could not be found or could not be created.

The \texttt{ssc\_module\_exec\_simple()} function is thread-safe, provided that the module called is itself thread-safe.  It is intended that all SSC modules are implemented in a thread-safe manner.

\subsection{Simple Method \#2}
A similar function to run a module exists that returns to the caller the first error message encountered.  This variation of \emph{exec} function is not thread-safe, as indicated by its name.  Example:

\begin{verbatimtab}[4]
// ... set up a data container with inputs ...

const char *error = ssc_module_exec_simple_nothread( "pvwattsv1", data );
if( error == NULL )
	printf("success!\n");
else
	printf( "module failed with error: %s\n", error );
\end{verbatimtab}


In this case, a \texttt{NULL} return value indicates that no error occurred.

\subsection{Running with Progress Updates, Warnings, and Errors}

The last (most complex) way to run a module is to provide a special handler that can reroute errors and warning messages, as well as provide progress updates to the controlling software.  To accomplish this, the client code must provide a \emph{handler} (aka \emph{callback}) function to SSC.  The handler function must have the signature below.

\begin{verbatimtab}
ssc_bool_t (*handler)( ssc_module_t module, 
	ssc_handler_t handle, 
	int action, 
	float f0, 
	float f1, 
	const char *s0, 
	const char *s1, 
	void *user_data );
\end{verbatimtab}


\notebox{This documentation is specific to the C language API for SSC handler functions.  Not all programming language interfaces included with SSC (e.g. MATLAB, Python, VBA) support the custom handler mechanism described here.  However, log messages (notices, warnings, errors) can still be retrieved after a simulation is completed using the \texttt{ssc\_module\_log()} function (see \S\ref{sec_messages}, although real-time progress updates cannot be issued.}

Supposing that such a function named \texttt{my\_ssc\_handler\_function()} has been defined, used the \texttt{ssc\_module\_exec\_with\_handler()} function to run the module.  You may pass an a generic data pointer to the function also, so that within the context of the handler the messages or progress updates can be routed accordingly.

\begin{verbatimtab}[4]
void *my_data = <some user data to send to the callback, or NULL>;

if ( ssc_module_exec_with_handler( module, data, my_ssc_handler_function, my_data ) )
	printf("success!\n");
else
	printf("fail!\n");
\end{verbatimtab}

The code below represents the default handler built into SSC.  Note that the handler function must return a boolean (0/1) value to indicate to SSC whether to continue simulating or not.  This provides the option to abort the simulation if a user has clicked a cancel button in the meantime, or similar.  The various parameters are used to convey SSC status information to the handler, and have different meanings (and data) depending on the \texttt{action\_type} parameter.

\begin{verbatimtab}[4]
static ssc_bool_t default_internal_handler( ssc_module_t p_mod, ssc_handler_t p_handler,
	int action_type, float f0, float f1, 
	const char *s0, const char *s1,
	void *user_data )
{
	if (action_type == SSC_LOG)
	{
		// print log messages to console
		std::cout << "Log ";
		switch( (int)f0 ) // determines type
		{
		case SSC_NOTICE: 
			std::cout << "Notice: " << s0 << " time " << f1 << std::endl; 
			break;
		case SSC_WARNING: 
			std::cout << "Warning: " << s0 << " time " << f1 << std::endl; 
			break;
		case SSC_ERROR: 
			std::cout << "Error: " << s0 << " time " << f1 << std::endl; 
			break;
		default: 
			std::cout << "Unknown: " << f0 << " time " << f1 << std::endl; 
			break;
		}
		return 1;
	}
	else if (action_type == SSC_UPDATE)
	{
		// print status update to console
		std::cout << "Progress " << f0 << "%:" << s1 << " time " << f1 << std::endl;
		return 1; // return 0 to abort simulation as needed.
	}
	else
		return 0;
}
\end{verbatimtab}

As noted in previous sections, the default handler simply prints warnings, errors, and simulation progress updates to the standard output stream on the console.  To implement a custom handler, it is recommended to copy the structure of the handler above, but to replace the output to the console with specialized handling for the messages and progress.  For example, in a graphical user interface program, the \texttt{user\_data} pointer could be used to pass in a pointer to a dialog class containing a progress bar and a text box.  The messages could be sent to the text box, and the progress bar updated appropriately.  The custom SSC handler function implemented in the graphical SSCdev tool (based on the excellent wxWidgets GUI library) is reproduced below, showing how messages and progess can be reported to the user.

\begin{verbatimtab}[4]
static ssc_bool_t my_handler( ssc_module_t p_mod, ssc_handler_t p_handler, int action, 
	float f0, float f1, const char *s0, const char *s1, void *user_data )
{
	wxProgressDialog *dlg = (wxProgressDialog*) user_data;
	if (action == SSC_LOG)
	{
		wxString msg;

		switch( (int)f0 )
		{
		case SSC_NOTICE: msg << "Notice: " << s0 << " time " << f1; break;
		case SSC_WARNING: msg << "Warning: " << s0 << " time " << f1; break;
		case SSC_ERROR: msg << "Error: " << s0 << " time " << f1; break;
		default: msg << "Unknown: " << f0 << " time " << f1; break;
		}

		// post the SSC message on the application-wide log window 
		app_frame->Log(msg);

		return 1;
	}
	else if (action == SSC_UPDATE)
	{
 		// update progress dialog with percentage complete
		dlg->Update( (int) f0, s0 );
		wxGetApp().Yield(true);

		return 1; // return 0 to abort simulation as needed.
	}
	else
		return 0;
}
\end{verbatimtab}

A third action type called \texttt{SSC\_EXECUTE} can be found in the SSC header file.  This is an advanced capability that is not described in this user guide, and is intended to be removed in the future from the SSC API.

\subsection{Retrieving Messages}
\label{sec_messages}

During simulation, a module may generate any number of (hopefully) informative messages about warnings or errors encountered.  The custom handler approach allows these messages to be reported to the user as the simulation progresses, but they are also stored in the module for retrieval later.  The \texttt{ssc\_module\_log()} function allows the client code to retrieve all the messages, regardless of which execute function was used to run the module.  Example:

\begin{verbatimtab}[4]
const char *text;
int type;
float time;
int index = 0;
while( (text = ssc_module_log( module, index++, &type, &time )) )
{
	switch( type ) // determines type
	{
	case SSC_NOTICE: 
		std::cout << "Notice: " << text << " time " << time << std::endl; 
		break;
	case SSC_WARNING: 
		std::cout << "Warning: " << text << " time " << time << std::endl; 
		break;
	case SSC_ERROR: 
		std::cout << "Error: " << text << " time " << time << std::endl; 
		break;
	default: 
		std::cout << "Unknown: " << text << " time " << time << std::endl; 
		break;
	}
}
\end{verbatimtab}

In essence, the \texttt{ssc\_module\_log()} is called repeatedly with an increasing index number until the function returns \texttt{NULL}, indicating that there are no more messages.  Along with the text of the message, information about the type (notice, warning, error) and the time that it was issued by the module are reported.

\notebox{Do not free the C string returned by \texttt{ssc\_module\_log()}.  It is a reference to internally managed memory.}

\section{Version Information}

Functions are included in SSC to return version information and details about the particular build.  For example:

\begin{verbatimtab}[4]
int version = ssc_version();
const char *build = ssc_build_info();

printf( "ssc version %d: %s\n", version, build );
\end{verbatimtab}

On Windows, this code may print:

\begin{verbatimtab}[4]
	ssc version 22: Windows 32 bit Visual C++ Nov 13 2012 18:44:14
\end{verbatimtab}

On Linux, a newer version of SSC may report something like:
\begin{verbatimtab}[4]
	ssc version 24: Unix 64 bit GNU/C++ Dec  5 2012 11:42:51
\end{verbatimtab}

\section{SSCdev}
\label{sec_sscdev}

SSCdev is the developer interface for SSC. It allows you to explore the SSC library libraries, view and edit variable values, and run simulations. SSCdev also includes a scripting language for building models in the development environment.

Use SSCdev before you start programming with the SSC API to understand how the modules you plan to use work. You can also use SSCdev while you program to test your algorithms.

\subsection{Menus}
\label{sec_sscdev_menus}

\subsubsection{File}
\label{sec_sscdev_menus_file}

\begin{itemize}
\item The New, Open, Save, and Save As commands are for working with scripting files (.lk). Clicking one of the commands switches to the Scripting tab.
\item Binary data files (.bdat) ...
\item Start Simulations runs the checked modules in the module browser in the order shown under Simulation sequence.
\item Run Script runs the script in the Script Editor.
\item Use the SSC Library commands to choose, load, and unload libraries. SSCdev displays the current library in the status bar at the bottom of the SSCdev window.
\item Recent Files lists recently opened scripting files (.lk) and SSC data files (.sscdat).
\item Exit closes SSCdev.
\end{itemize}

\subsubsection{Edit}
\label{sec_sscdev_menus_edit}

The two find commands search for text in the script editor.

\subsubsection{Help}
\label{sec_sscdev_menus_help}

The About command displays information about the current version of SSCdev.

\subsection{Module Browser}
\label{sec_sscdev_module_browser}

The module browser displays a list of modules in the current library and allows you to build a model and run simulations.

The status bar at the bottom of the SSCdev window displays the current library. It displays "SSC dynamic library not loaded" when you have not loaded a library. 

If the module browser is empty, you need to load a library. Click File, Choose SSC Library to load a library. 
\marginpar Why does that not work with 64-bit dll on my computer?  

To show a list of the module variables, click the module name.

To start a simulation, build a model by checking each module in the model in the order that you want simulations to run. If you try to 

\subsection{Variable Viewer}
\label{sec_sscdev_variable_viewer}


\subsection{A Simple Example without Scripting}
\label{sec_sscdev_example_no_scripting}

The following example shows how to use SSCdev to build a simple model of a photovoltaic system using the pvwattsv1 and annualoutput modules. These two modules have a small number of input variables, which will allow you to quickly build a functional model. In this example, you set the input variable values by hand. In the next example, you will build the same model using LK, which is SSCdev's built-in scripting language.

Required variables indicated by a \* in the Require column.
Optional variables for which a value is provided indicated by ?=[value]

You can use the module browser to explore the pvwattsv1 and annualoutput modules:

Click the pvwattsv1 name in the module browser to see the list of the module's 33 input and output variables. Of those variables, 22 are inputs (SSC\_INPUT), and only 6 are required and do not have default values (*).

Now click the annualoutput name to see the module's 11 variables. It requires 6 input values.

This model will use the pvwattsv1 module to read data from a weather file, define the system's size, array orientation and type of tracking, and derating factor, and calcualte values for the 1 by 8760 array storing the system's hourly electricity output over a single year. The annualoutput module will use the array as input, and calculate the system's total annual electricity output over a multi-year period.

In the module browser, click pvwattsv1 to display its variables. The 6 required variables are file\_name, system\_size, derate, track\_mode, azimuth, and tilt. These are the variables that SAM displays on the PVWatts Array input page.

Press the F5 key to start simulations. Nothing happens because you have to check a module to run it. Check the pvwatts1 module and press F5 again. This time, a message about the file\_name variable appears in the SSCdev notification panel. That is because file\_name is a required variable, but it does not yet have a value.

In the variable viewer, click Add, type "file\_name" for the variable name, assign it the SSC\_STRING data type, and click file to assign it the value of one of the TMY2 files included in the SDK Examples folder (for example, daggett.tm2).

Next, add the remaining 5 required variables shown in the module browser, using the data type and units shown in the table. For example, system\_size should be SSC\_NUMBER with a value in kilowatts. Be sure to use variable names and data types that exactly match those in the module browser.

When you are finished, you should see a table similar to Table \ref{table_ssc_dev_a}. This is the model's data container, which so far contains the input and output variables for the pvwattsv1 module.

Press the F5 key. The data container now includes the original input variables from Table \ref{table_ssc_dev_a} and the output variables generated by the simulation. You can show the variable values by checking them. The system's hourly output over a single year is ac, which is an array of 8,760 values.

To add the annualoutput module to the model, on the module browser, check annualoutput. Its name should appear second after pvwattsv1 in the simulation sequence to ensure that it runs after the pvwattsv1 module.\marginpar{have to use script to build a model because variable names do not match (eg, ac does not match energy\_bet\_net\_hourly)}

Click the annualoutput module name to display its variables. Of the 6 input variables, only analysis\_years is optional, so we must add the 5 required values to the data container. (These input variables are the same ones that SAM displays on the Annual Performance input page. ) For example \ref{table_ssc_dev_b} shows the inputs to model the system's performance over 30 years with an annual degradation of 0.5\% and no other adjustments to the system's output. Some of the input variables are arrays because they can store a different value for each year.\marginpar{Need to make a note that reader must be familiar with SAM to use modules}



Now we can expand our model to include two modules, the pvwattsv1 module and the annualoutput module.

In the module browser, check annualoutput. To display its variables, click the module name. It has 6 required inputs, which we have to add to the data container:

analysis\_years
energy\_availability
energy\_degradation





shading\_hourly
shading\_mxh
shading\_azal
shading\_diff



\begin{table}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
file\_name & system\_size & derate & track\_mode & azimuth & tilt\\
\hline
F:/SSC/examples/daggett.tm2 & 4.000000 & 0.860000 & 1.000000 & 180.000000 & 25.000000\\
\hline
\end{tabular}
\caption{The 6 required input variables for the pvwattsv1 module with their values}\label{table_ssc_dev_a}
\end{table}

\begin{table}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
file\_name & system\_size & derate & track\_mode & azimuth & tilt\\
\hline
F:/SSC/examples/daggett.tm2 & 4.000000 & 0.860000 & 1.000000 & 180.000000 & 25.000000\\
\hline
\end{tabular}
\caption{The 6 required input variables for the pvwattsv1 module with their values}\label{table_ssc_dev_b}
\end{table}

\subsection{Scripting}
\label{sec_sscdev_scripting}


\section{Language Interfaces}
\subsection{Native C/C++}
\subsection{MATLAB}
\subsection{Visual Basic for Applications (VBA)}
\subsection{Java via Native Interface}
\subsection{C\# and .NET}
\subsection{PHP}
\subsection{Python}
\subsection{Ruby-on-Rails}

\section{C API Reference}
\label{sec_api_ref}
\include{ssc_api_latex/sscapi_8h}

\end{document}
