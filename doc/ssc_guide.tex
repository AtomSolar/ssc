\documentclass{article}
\usepackage{geometry} 
\geometry{letterpaper} 
%%%% Uncomment below to begin paragraphs with an empty line %%%%
\usepackage[parfill]{parskip} 
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{moreverb}
%\usepackage[section]{placeins}
%\usepackage[below]{placeins}
\usepackage{epstopdf}

% Begin from doxygen


%\usepackage{makeidx}
%\usepackage{natbib}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
%\usepackage{ifthen}
\usepackage[table]{xcolor}
\usepackage{textcomp}
\usepackage{alltt}
\usepackage[pdftex,
            pagebackref=true,
            colorlinks=true,
            linkcolor=blue,
            unicode
           ]{hyperref}
%\usepackage[utf8]{inputenc}
%\usepackage{mathptmx}
%\usepackage[scaled=.90]{helvet}
%\usepackage{courier}
%\usepackage{sectsty}
\usepackage[titles]{tocloft}
\usepackage{doxygen}
\lstset{language=C++,inputencoding=utf8,basicstyle=\footnotesize,breaklines=true,breakatwhitespace=true,tabsize=8,numbers=left }
%\makeindex
\setcounter{tocdepth}{3}
%\renewcommand{\footrulewidth}{0.4pt}
%\renewcommand{\familydefault}{\sfdefault}
%\hfuzz=15pt
%\setlength{\emergencystretch}{15pt}
%\hbadness=750
%\tolerance=750

% End from doxygen

%\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\newcommand\bslash{\char`\\}
\newcommand\lt{\char`\<}
\newcommand\gt{\char`\>}
\newcommand{\tab}{\hspace*{2em}}
\newcommand{\supers}[1]{\ensuremath{^\textrm{{\scriptsize #1}}}}
\newcommand{\subs}[1]{\ensuremath{_\textrm{{\scriptsize #1}}}}
\newcommand{\notebox}[1]{ \begin{center}\framebox[5.5in]{\begin{minipage}[t]{5.0in}\textbf{Note: }#1\end{minipage}}\end{center}}

\title{SSC Reference Manual}
\author{Aron Dobos \& Paul Gilman}

\begin{document}

\maketitle
\vspace{2.5in}
\begin{abstract}
The SSC (SAM Simulation Core) software library implements the underlying renewable energy system modeling calculation engine utilitized by the popular desktop System Advisor Model (SAM) tool.  SSC provides a simple and programmer-friendly application programming interface (API) that allows developers to directly integrate SAM calculations into other tools.  The API includes mechanisms to set input variable values, run simulations, and retrieve calculated outputs.  The library is provided to users as pre-compiled binary dynamic libraries for Windows, Mac OSX, and Linux, with the bare minimum system library dependencies.  While the native API language is ISO-standard C, language bindings for MATLAB, and Python are included.  The API and model implementations are thread-safe and reentrant, allowing the software to be efficiently utilized in a parallel computing environment.

This document describes the software architecture of SSC, introduces the SSC Development Environment tool, explains how to set up simulations from code, query the library for variable information, and provides examples and ``case studies" in various programming languages to ease the adoption of SSC into other systems.  

\textbf{Note.} The reader is assumed to have familiarity with the C programming language, as well as some level of proficiency using the System Advisor Model (SAM) tool.
\end{abstract} 

\newpage
\tableofcontents
%%\listoffigures
%%\listoftables
\newpage

\section{Overview}
\label{sec_overview}

The SSC software development kit (SDK) provides tools for creating models of renewable energy systems using the SSC library. The System Advisor Model (SAM) desktop application is a user-friendly front-end for the SSC library that uses SSC modules to perform all system performance and financial calculations. This manual assumes that the reader is familiar with SAM's suite of performance and financial models, input and output variables, and other capabilities. The SDK consists of the application programming interface (API), library, programming language wrappers, integrated development environment, and code samples.

\subsection{Framework Description}

The SSC framework provides a generic mechanism for running modules, setting values of module inputs, and reading values of module outputs. The mechanisms are generic because they do not depend on the module. For example, the same mechanism provides access to the PVWatts (\texttt{pvwattsv1}) and Utility IPP (\texttt{ippppa}) modules.  

Using an SSC module is analogous to calling a function in a programming language: you pass parameter values to the function, run the function, and then read values returned by the function.  In SSC, you store input variables in a data container, run the module, and retrieve outputs from the same data container:

\begin{enumerate}
\item Create a data container of type \texttt{ssc\_data\_t} for model input variables.
\item Call a simulation module such as \texttt{pvwattsv1} or \texttt{ippppa} of type \texttt{ssc\_module\_t} to process variables in the data container. If the module runs successfully, it populates the data container with output variables. If it fails, it generates error messages.
\item Retrieve output variable values from the data container, or error messages from the module.
\end{enumerate}

\subsection{Modeling an Energy System}
\label{sec_modeling_systems}
The SSC modules process weather data files, simulate energy system component performance, and calculate project cash flows. Table~\ref{tab_sample_modules} lists some of the SSC modules.\marginpar{For a complete list, see?}

\begin{table}[ht]
\begin{center}
\begin{tabular}{ll}
Module & Description \\
\hline
\texttt{pvwattsv1} & Implements the NREL PVWatts model for PV performance\\
\texttt{pvsamv1} & Implements the component-based PV models in SAM\\
\texttt{wfreader} & Reads standard format weather data files (TM2, TM3, EPW, SMW)\\
\texttt{irradproc} & General purpose irradiance processor for calculating POA\\
\texttt{windpower} & Implements the NREL wind turbine and simple wind farm model\\
\texttt{cashloan} & Implements residential and commercial cashflow economic model\\
\texttt{ippppa} & Commercial PPA and Independent Power Producer (IPP) financial models\\
\texttt{annualoutput} & Calculates degraded out-years system output for the analysis period\\
\texttt{utilityrate} & Calculates the value of energy using complex utility rate structures\\
\end{tabular}
\caption{Some commonly used SSC modules}
\label{tab_sample_modules}
\end{center}
\end{table}

Creating a technical model of a renewable energy system or a technoeconomic model of a renewable energy project in SSC involves choosing a set of modules. For example, a model of a residential photovoltaic project might use the following modules:\marginpar{Would this example require a weather reader too?}

\begin{enumerate}
\item \texttt{pvwattsv1}: The system parameters are used to calculate the hourly PV system performance.
\item \texttt{annualoutput}: The availability and degradation factors are applied to the annual energy output for the duration of the specified analysis period.
\item \texttt{utilityrate}: The value of the generated energy is calculated given the specifics of the complex utility rate structure, and the first year's hourly energy value is reported, along with the annual total value of energy at each year of the analysis period.
\item \texttt{cashloan}: Given the amount of the energy produced each year and the dollar value of this energy, this module calculates the cost of energy, net present value, and other metrics of the system based on specified system cost, incentives, operation and maintainance costs, taxes, and loan parameters.
\end{enumerate}

In this example, the modules would run in the order shown above, with outputs of each module serving as inputs for the next. Because the modules do not necessarily use the same names or units for variables representing the same quantities, lines of code in the program calling the modules may be required to translate values.  For example, the \texttt{pvwattsv1} module has an output variable \texttt{ac} which is the hourly energy in kWh produced by the system, while the \texttt{annualoutput} module requires an input with the name \texttt{energy\_net\_hourly}./marginpar{Must all modules use the same data container, or can you set up a separate container for each module?}  It is up to the user to ensure that variables are translated appropriately between the outputs of one module and the inputs of another, including any units conversions that may be necessary.  Luckily, SSC provides exhaustive documentation of all of the input variables required by a module and all of the outputs that will be calculated.  Working with input and output variables will be the topic of a subsequent chapter./marginpar{Where is the documentation of input and output variables?}

\section{A Basic Example: PVWatts}

In this section, we will write a simple command-line C program to calculate the monthly energy production of a 1 kW PV system at a particular location.  The complete source code for this example program is included with the SSC SDK in the file \texttt{example1\_pvwatts.c}.

\subsection{Program Skeleton}

The SSC API is defined a C header called \texttt{sscapi.h}, and this file must be included in your program before any SSC functions can be called.  We will assume that the weather file is specified as a command line argument, and is one of the types that the \texttt{pvwattsv1} can read (TM2, TM3, EPW, SMW).  The skeleton of our program might look like the listing below.

\begin{verbatimtab}[4]
#include <stdio.h>
#include "sscapi.h"

int main(int argc, char *argv[])
{
	if ( argc < 2 )
	{
		printf("usage: pvwatts.exe <weather-file>\n");
		return -1;
	}
 
	// run PVWatts simulation for the specified weather file
	
	return 0;
}
\end{verbatimtab}

\subsection{Setting up data inputs}

Now we will fill in the comment in the middle of the code step-by-step.  Referring to the three step process outlined in Section~\ref{sec_overview}, the first task is to create a data container.  This is done with the \texttt{ssc\_data\_create()} function call, which returns an \texttt{ssc\_data\_t} type.  If for some reason the function call fails due to the system having run out of memory, \texttt{NULL} will be returned.  It is important to check the result to make sure the data container was created successfully.

\begin{verbatimtab}[4]
	ssc_data_t data = ssc_data_create();
	if ( data == NULL )
	{
		printf("error: out of memory.\n");
		return -1;
	}
\end{verbatimtab}

Next, we assign the input variables required by the \texttt{pvwattsv1} module.  In \S\ref{chap_variables}, we will show how to obtain information about the data types, names, labels, and units of variables.  For now, it suffices to say that SSC supports data as numbers, text strings, arrays, matrices, and tables.

\begin{verbatimtab}[4]
	ssc_data_set_string( data, "file_name", argv[1] ); // set the weather file name
	ssc_data_set_number( data, "system_size", 1.0f );  // system size of 1 kW DC
	ssc_data_set_number( data, "derate", 0.77f );      // system derate
	ssc_data_set_number( data, "track_mode", 0 );      // fixed tilt system
	ssc_data_set_number( data, "tilt", 20 );           // 20 degree tilt
	ssc_data_set_number( data, "azimuth", 180 );       // south facing (180 degrees)
\end{verbatimtab}

At this point, we have a data container with six variables that are the input parameters to the module that we wish to run.  

\subsection{Simulating and retrieving outputs}
\label{sec_ex_pvwatts_module}

Next, an instance of the module itself must be created, per below.  The name of the desired module must be passed to the \texttt{ssc\_module\_create()} function.  If the specified module name is not recognized, or the system is out of memory, the function may return \texttt{NULL}.

\begin{verbatimtab}[4]
	ssc_module_t module = ssc_module_create( "pvwattsv1" );
	if ( NULL == module )
	{
		printf("error: could not create 'pvwattsv1' module.\n");
		ssc_data_free( data );
		return -1;
	}
\end{verbatimtab}

Next, the simulation must be run.  If all the required input variables have been defined in the data container and have appropriate data types and values, the simulation should finish successfully.  Otherwise, an error will be flagged.  

\begin{verbatimtab}[4]
	if ( ssc_module_exec( module, data ) == 0 )
	{
		printf("error during simulation.\n");
		ssc_module_free( module );
		ssc_data_free( data );
		return -1;
	}
\end{verbatimtab}

By default, the \texttt{ssc\_module\_exec()} function prints any log or error messages to standard output on the console.  There is a more complex way to run a simulation that can reroute messages somewhere else, for example if a program wanted to pop up a message box or collect all messages and return them to the sure.  This will be discussed in later sections.

Assuming that the simulation succeeded, it is now time to extract the calculated results.  Modules may calculate hundreds of outputs, but for this example, we simply are interested in the total AC energy produced by the 1 kW PV system.  As it turns out, \texttt{pvwattsv1} only provides the hourly data, so it is up to us to sum up the hourly values.  The code snippet below shows how to query the data object for the \texttt{ac} variable and aggregate it.

\begin{verbatimtab}[4]
	double ac_total = 0;
	int len = 0;
	ssc_number_t *ac = ssc_data_get_array( data, "ac", &len );
	if ( ac != NULL )
	{
		int i;
		for ( i=0; i<len; i++ )
			ac_total += ac[i];
		printf("ac: %lg kWh\n", ac_total*0.001 );
	}
	else
	{
		printf("variable 'ac' not found.\n");
	}
\end{verbatimtab}

\subsection{Cleaning up}

We're now finished simulating the PV system and retrieving the results.  To avoid filling up the computer's memory with unneeded data objects, it is important to free the memory when it is no longer needed.  To this end, the \texttt{ssc\_module\_free()} and \texttt{ssc\_data\_free()} functions are provided.  Note that after calling one of these functions, the \texttt{module} and \texttt{data} variables are invalidated and cannot be used unless reassigned to another or a new data object or module.

\begin{verbatimtab}	
	ssc_module_free( module );
	ssc_data_free( data );
\end{verbatimtab}

\subsection{Compiling and running}

Using the MinGW compiler toolchain on Windows, it is very straightforward to compile and run this example.  Simply issue the command below at the Windows command prompt (\texttt{cmd.exe} from Start/Run), assuming that the \texttt{sscapi.h} header file and 32-bit \texttt{ssc.dll} dynamic library is in the same folder as the source file.  The complete source code for this example is included in the SSC SDK.  This example was tested with MinGW gcc version 4.6.2.

\begin{verbatim}
c:\> gcc example1_pvwatts.c ssc.dll -o pvwatts.exe
\end{verbatim}

To run the program, specify a weather file on the command-line.  Here, we use TMY2 data for Daggett, CA, which is included in the SDK as \emph{daggett.tm2}.

\begin{verbatim}
c:\> pvwatts.exe daggett.tm2
ac: 1468.54 kWh
\end{verbatim}

If all goes well, the total annual AC kWh for the system is printed on the console.

\subsection{Some additional comments}

The \texttt{ssc\_data\_t} and \texttt{ssc\_module\_t} data types are opaque references to internally defined data structures.  The only proper way to interact with variables of these types is using the defined SSC function calls.  As listed in the \texttt{sscapi.h} header file, both are typedef'd as \texttt{void*}.


\section{Data Variables}
\label{sec_variables}

Simulation model inputs and outputs are stored in a data container of type \texttt{ssc\_data\_t}, which is simply a collection of named variables.  Internally, the data structure is an unordered map (hash table), permitted very fast lookup of variables by name.  Every input and output variable in SSC is designated a name, a \emph{variable type}, and a \emph{data type}, along with other meta data (labels, units, etc). 

The variable name is mechanism by which data are identified by SSC, and the user is required to supply input variables with names that SSC has predefined.  Names can contain letters, numbers, and underscores.  Although names can be defined with upper and lower case letters, SSC does not distinguish between them internally: hence \texttt{Beam\_Irradiance} is the same variable as \texttt{beam\_irradiance}.

\subsection{Variable Types}

The \emph{variable type} identifies each variable as an input, output, or in-out variable.  In the SSC API, these values are defined by the constants reproduced below.

\begin{verbatimtab}
#define SSC_INPUT 1
#define SSC_OUTPUT 2
#define SSC_INOUT 3
\end{verbatimtab}

Input variables are required to be set by the user before a module is called, while output variables are calculated by the module and assigned to the data container when the module has finished running.  In-out variables are supplied by the user before the model runs, and the model transforms the value in some fashion.

Note that from the perspective of the data container, inputs and outputs are stored without distinction in an equivalent manner.  Thus, it is impossible to tell simply from the contents of a data container whether a variable was an input or an output - it is just a pile of data.  It is only the simulation modules that specify the variable type.

\subsection{Data Types}

Every variable in SSC is assigned a particular data type, and each simulation module to specifies the data type of each variable required as input, as well as the data type of each output.  SSC can work with numbers, text strings, one-dimensional arrays, two-dimensional matrices, and tables.  The data type constants are listed below.

\begin{verbatimtab}
#define SSC_INVALID 0
#define SSC_STRING 1
#define SSC_NUMBER 2
#define SSC_ARRAY 3
#define SSC_MATRIX 4
#define SSC_TABLE 5
\end{verbatimtab}

All numbers are stored using the \texttt{ssc\_number\_t} data type.  By default, this is a typedef of the 32-bit floating point C data type (\texttt{float}).  The purpose of using \texttt{float} instead of the 64-bit \texttt{double} is to save memory.  While a simulation module may perform all of its calculations internally using 64-bit precision floating point, the inputs and results are transferred into and out of SSC using the smaller data type.

Arrays (1-D) and matrices (2-D) store numbers only - there is no provision for arrays or matrices of text strings, or arrays of tables.  Arrays and matrices are optimized for efficient storage and transfer of large amounts of numerical data.  For example, a photovoltaic system simulation at 1 second timesteps for a whole year would produce 525,600 data points, and potentially several such data vectors might be reported by a single simulation model.  This fact underscores the reasoning to use the 32-bit floating point data type: just 20 vectors of 525,600 values each would require 42 megabytes of computer memory.

SSC does not provision separate storage for integers and floating point values - all numbers are stored internally as floating point.  However, a module may specific a numeric input with the \emph{integer} constraint which is checked automatically before the module is run.  Constraints will be discussed later.

Text strings (\texttt{SSC\_STRING})  are stored as 8-bit characters.  SSC does not support multi-byte or wide-character string representations, and all variable names and labels use only the 7-bit ASCII Latin alphabet.  Consequently, text is stored as null ('\textbackslash 0') terminated \texttt{char*} C strings.  Weather file names are common input variables that use the \texttt{SSC\_STRING} data type.

The table (\texttt{SSC\_TABLE}) data type is the only hierarchical data type in SSC.  Essentially, it allows a simulation module to receive or return outputs in a structured format with named fields.  A table is nothing more than a named variable that is itself a data container, which can store any number of named variables of any SSC data type.  Currently, most SSC modules do not make heavy use of tables, but they are fully implemented and supported for future complex modules that may be added.

\subsection{Variable Documentation}
\label{sec_variable_docs}

As stated before, each module defines all of the input variables it requires and output variables it produces.  Since SSC is a model simulation framework that contains within it numerous calculation modules that each may have hundreds of variables, it is impractical to separate to the documentation of variables from their definitions.  Otherwise, the documentation would tend to be consistently out of date as modules are updated and new ones are added.  Section~\ref{sec_explicit_modules} details how to create modules that can be queried for this type of information.

\begin{table}[ht]
\begin{center}
\begin{tabular}{ll}
Field & Description\\
\hline
Variable type & \texttt{SSC\_INPUT}, \texttt{SSC\_OUTPUT}, \texttt{SSC\_INOUT} \\
Data type & \texttt{SSC\_NUMBER}, \texttt{SSC\_STRING}, \texttt{SSC\_ARRAY}, \texttt{SSC\_MATRIX}, \texttt{SSC\_TABLE} \\
Name & Variable name (case insensitive) \\
Label & A description of the variable's purpose \\
Units & The units of the numerical value(s) \\
Meta & Additional information. Could specify encoding of values, see below. \\
Group & General category of variable, e.g. ``Weather'', ``System Input'' \\
Required & Specifies whether the variable must be assigned a value. See \S\ref{sec_def_const} \\
Constraints & Constraints on the values or number of values. See \S\ref{sec_def_const} \\
UI Hints & Suggestions on how to display this variable.  Currently unused. \\
\end{tabular}
\caption{Variable information provided by SSC}
\label{tab_varinfo}
\end{center}
\end{table}

Consequently, SSC provides functions in the API to return information about all of the variables defined by a module.  Each variable specifies the information shown in Table~\ref{tab_varinfo}.

To obtain information for a variable, a module is queried using the \texttt{ssc\_module\_var\_info()} function, which returns a \texttt{ssc\_info\_t} reference.  The \texttt{ssc\_module\_var\_info()} function is called repeatedly with an index variable that is incremented by the user to cycle through all of the variables defined by the module.  An example is shown below, assuming that the variable \texttt{module} has been successfully created for a particular simulation module (e.g., see \S\ref{sec_ex_pvwatts_module}).  Querying SSC for available modules is discussed in \S\ref{sec_modules_querying}.

\begin{verbatimtab}[4]
int i=0;
ssc_info_t p_inf = NULL;
while ( p_inf = ssc_module_var_info( module, i++ ) )
{
	// var_type: SSC_INPUT, SSC_OUTPUT, SSC_INOUT
	int var_type = ssc_info_var_type( p_inf );

	// data_type: SSC_STRING, SSC_NUMBER, SSC_ARRAY, SSC_MATRIX, SSC_TABLE   
	int data_type = ssc_info_data_type( p_inf );
      
	const char *name = ssc_info_name( p_inf );
	const char *label = ssc_info_label( p_inf );
	const char *units = ssc_info_units( p_inf );
	const char *meta = ssc_info_meta( p_inf );
	const char *group = ssc_info_group( p_inf );
	const char *required = ssc_info_required( p_inf );
	const char *constraints = ssc_info_constrants( p_inf );

	// here, you can print all of this data to text file
	// or present it in another way to the user

	printf( "%s %s (%s) %s\n", name, label, units, meta );
}

\end{verbatimtab}

The interactive SSCdev tool provided with the SSC library automatically generates all of this documentation for all modules in an interactive GUI spreadsheet-style interface.  This utility will be discussed in more detail in \S\ref{sec_sscdev_vars}.

\subsection{Default Values and Constraints}
\label{sec_def_const}

Sometimes there are so many input variables for a module that SSC assigns reasonable default values for some of the inputs if they are not explicitly specified by the user.  In other cases, some inputs may only have relevance for advanced users, and so a standard default value is provided that is recommended for the majority of simulations.  If a default value is provided, it is specified in the \emph{required} field of the variable information table.

If the \emph{required} field contains \texttt{``*''}, this means that there is no default value and the user must specify one in all cases.  If the \emph{required} field begins with the character \texttt{``?''}, it means that the variable is optional, and that SSC will use the value assigned by the user if it is provided.  The manner in which an optional variable affects the calculation is specific to each module, and so cannot be expanded upon here.

A default value is provided by SSC if the \emph{required} field appears as \texttt{``?=<value>''}, where \texttt{<value>} may be a number, a text string, or comma-separated array, depending on the data type of the variable.  In effect, this means that the variable always be given a value before simulation, but the user need not specify it.  For example, the \texttt{pvwattsv1} module specifies \texttt{rotlim} (tracker rotation limit) variable's \emph{required} field as \texttt{``?=45.0''}, meaning that unless the user specifies a different value, a rotation limit of 45 degrees is used.

In addition to providing some default values, SSC performs some data input validation before running a simulation using the \emph{constraints} field.  This field may optionally define any number of flags recognized by SSC that may limit the valid range of a numeric input variable, or define the required length of an input array.  A selection of the flags used by SSC is listed in Table~\ref{tab_constraints}.  Note that these flags are defined internally by the modules, and are not editable by users.  Also, in the case that the \emph{constraints} field is empty, that does not necessarily imply that any values are acceptable - the module writer may have inadvertently omitted a constraint flag, and may instead manually check each variable when the module runs.

\begin{table}[ht]
\begin{center}
\begin{tabular}{ll}
Flag & Description\\
\hline
\texttt{MIN=<value>} & Specifies the minimum permissible value for a number \\
\texttt{MAX=<value>} & Specifies the maximum permissible value for a number \\
\texttt{BOOLEAN} & Requires the number to be equal to 0 (false) or 1 (true) \\
\texttt{INTEGER} & Requires the number to be an integer value \\
\texttt{POSITIVE} & Requires the number to have a positive, non-zero value \\
\texttt{LOCAL\_FILE} & Requires the text string to be a local file on disk that is readable and exists \\
\end{tabular}
\caption{Some constraints recognized by SSC}
\label{tab_constraints}
\end{center}
\end{table}

Constraints can be combined to further restrict the value of a number.  For example, in \texttt{pvwattsv1}, the \texttt{track\_mode} variable's constraints field is \texttt{``MIN=0,MAX=3,INTEGER''}.  This specification limits the possible values of the variable to 0, 1, 2, or 3, which are the numeric values associated with a fixed, 1-axis, 2-axis, or azimuth-axis tracking PV system.

\subsection{Manipulating Data Containers}
\label{sec_data_manip}

As was shown in the initial PVWatts example, a data container is created and freed using the \texttt{ssc\_data\_first()} and \texttt{ssc\_data\_next()} functions.  Here, some additional functions for working with data containers are explored.

The \texttt{ssc\_data\_unassign()} function removes a variable from the container, releasing any memory associated with it.  To erase all of the variables in a container and leave it empty (essentially resetting it), use the \texttt{ssc\_data\_clear()} function.  For example:

\begin{verbatimtab}
ssc_data_unassign( data, "tilt" ); // remove the 'tilt' variable

ssc_data_clear( data ); // reset the container by erasing all the variables
\end{verbatimtab}


To find out the names of all variables in a container, functions \texttt{ssc\_data\_first()} and \texttt{ssc\_data\_next()} are used.  These functions return the name of a variable, or \texttt{NULL} if there are no more variables in the container.  The \texttt{ssc\_data\_query()} function returns the data type of the specified variable, which is useful for subsequently retrieving its value.  The example below prints out the text of all the string variables in a data container:

\begin{verbatimtab}[4]
const char *name = ssc_data_first( data );
while( name != 0 )
{
	// do something, like query the data type
	int type = ssc_data_query( data, name );

	if ( type == SSC_STRING )
	{
		const char *text = ssc_data_get_string( data, name );
		printf("string variable %s: %s\n", name, text );
	}

	name = ssc_data_next( data );
}
\end{verbatimtab}

See the API reference in \S\ref{sec_api_ref} for detailed documentation of each function's parameters and return values.

\subsection{Assigning and Retrieving Values}

This section discusses the particulars of assigning and retrieving variable values.  Note that assigning a variable that already exists in the container causes the old value to be erased.

\subsubsection{Numbers}

Numbers are transferred and stored using the \texttt{ssc\_number\_t} data type.  To assign a value:

\begin{verbatim}
ssc_data_set_number( data, "track_mode", 2 ); // integer value
ssc_data_set_number( data, "tilt", 30.5f ); // floating point value

ssc_number_t azimuth = 182.3f;
ssc_data_set_number( data, "azimuth", azimuth ); // from a variable
\end{verbatim}

To retrieve a numeric value, it must be declared first, since the retrieval function returns true or false.  False is returned if the specified variable does not exist in the data container.

\begin{verbatimtab}[4]
ssc_number_t value;
if( ssc_data_get_number( data, "tilt", &value ) )
	printf( "tilt = %f\n", value );
else
	printf( "not found\n" );
\end{verbatimtab}

\subsubsection{Arrays}

Arrays are passed to SSC using standard C arrays (pointers), along with the length of the array. Examples:

\begin{verbatimtab}
ssc_number_t monthdays[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
ssc_data_set_array( data, "nday", monthdays, 12 );

// dynamically allocate an array of size len
ssc_number_t *xx = (ssc_number_t*) malloc( sizeof(ssc_number_t)*len );
for( i=0; i<len; i++ ) xx[i] = i*i;

ssc_data_set_array( data, "isquared", xx, len );

free( xx ); // SSC does not take ownership, so free any arrays here.
\end{verbatimtab}

\notebox{When assigning an array, SSC makes an internal copy, and does not take ownership of the array passed in.  Thus it is up to the user to deallocate any memory created in the client code as appropriate.}

Array data is retrieved from SSC using the \texttt{ssc\_data\_get\_array()} function.  The length of the retrieved array is returned in the length reference parameter.  If the requested variable is not assigned, or is not an \texttt{SSC\_ARRAY}, \texttt{NULL} is returned.  Example:

\begin{verbatimtab}[4]
int len = 0;
const ssc_number_t *array = ssc_data_get_array( data, "xx", &len );

if( array != NULL && len > 0 )
{
	printf("len: %d, first item=%f\n", len, array[0] );
}
\end{verbatimtab}

\notebox{The \texttt{ssc\_data\_get\_array()} returns a reference to internally managed memory: do not deallocate or otherwise change the array returned by it.  This is done to improve efficiency when working with large data vectors.}

\subsubsection{Matrices}

Matrices are two dimensional arrays of numbers.  In SSC, matrices are stored as one contiguous array, in row-major order.  Like arrays, they consist of \texttt{ssc\_number\_t} data and are passed to SSC using standard C arrays, along with the number of rows and columns.

Row-major ordering means that the two dimensional array is flattened into a single dimensional vector.  In a 4x3 matrix, the flattened vector will have 12 values in which indices [0..3] represent the first row, [4..7] the second row, and [8..11] the third row.  Example:

\begin{verbatimtab}[4]
ssc_number_t mat[12] = { 4,4,5,1,
                         6,7,2,5,
                         1,6,2,3 };

ssc_data_set_matrix( data, "mat1", mat, 4, 3 );
\end{verbatimtab}

\notebox{SSC creates an internal copy of the matrix passed to \texttt{ssc\_data\_set\_matrix()}.  If the matrix was allocated dyamically, it is up to the user written client code to deallocate it properly: SSC does not take ownership.}

Matrices are returned in the same format.  If the requested variable does not exist or is not a matrix, \texttt{NULL} is returned.  Example:

\begin{verbatimtab}[4]
int nrows, ncols;
ssc_number_t *mat = ssc_data_get_matrix( data, "mat1", &nrows, &ncols );

if( mat != NULL && nrows == 4 && ncols == 3 )
{
	int r, c, index = 0;
	for( r=0; r<nrows; r++ )
		for( c=0; c<ncols; c++ )
			printf( "mat[%d,%d]=%f\n", r, c, mat[index++] );
}
\end{verbatimtab}
\notebox{The \texttt{ssc\_data\_get\_matrix()} returns a reference to internally managed memory: do not deallocate or otherwise change the array returned by it.}

\subsubsection{Strings}

SSC supports null-terminated ASCII text strings as a data type.  Setting a string value is straightforward.  SSC creates an internal copy of the string data.  Examples:
\begin{verbatimtab}
ssc_data_set_string( data, "weather_file", "c:/Data/Weather/TX Abilene.tm2" );

const char *location = "Hawaii";
ssc_data_set_string( data, "location", location );
\end{verbatimtab}

Retrieving strings is similarly straightforward:

\begin{verbatimtab}[4]
const char *location = ssc_data_get_string( data, "location" );
if( location != NULL )
	printf("location = %s\n", location );
\end{verbatimtab}

\notebox{Do not free or modify the pointer returned by \texttt{ssc\_data\_get\_string()}.  A reference to an internally managed character byte array is returned.}

\subsubsection{Tables}

Tables provide a way to communicate data to SSC in a hierarchical structure format.  This data type is provisioned for future simulation modules, but current ones do not use this data type.  Nonetheless, the SSCdev utility (\S\ref{sec_sscdev}) fully supports tables.  Before a table can be assigned, it must be created and filled with variables.  A table is simply a normal data container.  Example:

\begin{verbatimtab}
ssc_data_t table = ssc_data_create(); // create an empty table
ssc_data_set_string( table, "first", "peter" );
ssc_data_set_string( table, "last", "jones" );
ssc_data_set_number( table, "age", 24 );

ssc_data_set_table( data, "person", table ); // assign the table

ssc_data_free( table ); // free the table after it is assigned
\end{verbatimtab}

Since a table is a just an \texttt{ssc\_data\_t} object, it can store any SSC data type, including another table.  This structure allows for nested tables, as potentially needed by a future complicated simulation module.

\notebox{SSC creates an internal copy of the table and all of its variables.  As such, the table should be deallocated after it is assigned, per the example above.}

Retrieving a table is a straightforward operation:

\begin{verbatimtab}[4]
ssc_data_t table = ssc_data_get_table( data, "person" );
if( table != NULL )
{
	printf( "person.first = %s\n", ssc_data_get_string( table, "first" ) );
	printf( "person.last = %s\n", ssc_data_get_string( table, "last" ) );
}
// do not free the 'table' variable: it is internal to SSC
\end{verbatimtab}

\notebox{The \texttt{ssc\_data\_get\_table()} function returns an internal reference to a data container.  Do not deallocate or otherwise modify the returned reference.}

Note that the \texttt{ssc\_data\_first()} and \texttt{ssc\_data\_next()} functions described in \S\ref{sec_data_manip} can be used to determine all of the fields of a table.


\section{Simulation Modules}
\label{sec_modules}

The SSC framework exposes several different simulation modules that calculate outputs given inputs.  Each module can run independently of all the others, provided that all the input variables that are required are provided by the user.  The System Advisor Model (SAM) tool often runs several SSC modules in succession to simulate the whole system performance and economic evaluation.  In between successive calls to different SSC modules, SAM may change the names or scale the output variables of one module to set it up with appropriate inputs for the next one, as explained in \S\ref{sec_modeling_systems}.

There are four different ways to invoke simulation modules.  Each method involves a different level of interaction during the execution of the model, differences in how errors and warnings are retrieved, and the appropriateness for use in a multithreaded environment.  The four methods are subsequently presented, followed by sections on retrieving error messages and querying the SSC library to learn the names of available compute modules.

\subsection{Simple Method \#1}

The simplest way to call a module is to use the \texttt{ssc\_module\_exec\_simple()} function.  This method prints any warnings or errors to the console, and simply returns true or false. The PVWatts example from earlier could be written as:

\begin{verbatimtab}[4]
ssc_data_t data = ssc_data_create();
ssc_data_set_string( data, "file_name", "TX Abilene.tm2" );
ssc_data_set_number( data, "system_size", 4 );
ssc_data_set_number( data, "derate", 0.77f );
ssc_data_set_number( data, "track_mode", 0 );
ssc_data_set_number( data, "tilt", 20 );
ssc_data_set_number( data, "azimuth", 180 );

if( ssc_module_exec_simple( "pvwattsv1", data ) )
{
	int i, len;
	ssc_number_t ac_sum = 0;
	ssc_number_t *ac = ssc_data_get_array( data, "ac", &len );
	for( i=0;i<len;i++ ) ac_sum += ac[i];
	printf( "success, ac: %f Wh\n", ac_sum );

}
else
	printf( "an error occured\n" );

ssc_data_free( data );
\end{verbatimtab}

Note that there is no need to explicitly create an \texttt{ssc\_module\_t} object using \texttt{ssc\_module\_create()}; the function will return false if the module name specified could not be found or could not be created.

The \texttt{ssc\_module\_exec\_simple()} function is thread-safe, provided that the module called is itself thread-safe.  It is intended that all SSC modules are implemented in a thread-safe manner.  The primary downside to using this simple invocation method is that the host program receives no progress updates, and the error messages and warnings cannot be programmatically retrieved after the module has finished running.

\subsection{Simple Method \#2}
The second module invocation method is very similar to the first, except that the first error message is returned to the caller.  Because this function uses a global variable to store the first error messages during the course of module execution, this invocation method should not be used in a multithreaded host environment.  This is explicitly indicated by the \texttt{\_nothread} suffix on the function name.  Example:

\begin{verbatimtab}[4]
// ... set up a data container with inputs ...

const char *error = ssc_module_exec_simple_nothread( "pvwattsv1", data );
if( error == NULL )
	printf("success!\n");
else
	printf( "module failed with error: %s\n", error );
\end{verbatimtab}

In this case, a \texttt{NULL} return value indicates that no error occurred.  As with the simplest method 1, there is no way to retrieve additional errors or warnings after the module has finished running.  Progress updates are also not provided to the calling environment.

\subsection{Explicit Module Instantiation}
\label{sec_explicit_modules}

A third way to run a computation module is to explicitly create a module object, execute it with a data container, and then release it.  This method is introduced with the PVWatts example in Section~\ref{sec_ex_pvwatts_module}, and is discussed in more detail in this section.

The SSC function \texttt{ssc\_module\_create(...)} function is used to create a new instance of a computation module.  The function returns an opaque reference of type \texttt{ssc\_module\_t} to the module object, or returns \texttt{NULL} if the module could not be created.  The single parameter required is the name of the module requested.  If a module is created successfully, it must eventually be released when it is no longer needed via the \texttt{ssc\_module\_free(...)} function.  Example:

\begin{verbatimtab}[4]
// ... set up a data container with inputs ...
ssc_module_t module = ssc_module_create( "cashloan" );
if ( NULL == module )
	printf("could not create 'cashloan' module!\n");
else
{
	// ... query the module for variable info or run it ...

	// free the module when it is no longer needed
	ssc_module_free( module );
}
\end{verbatimtab}

The advantage of explicitly creating a module is that all errors, warnings, and log messages generated during the course of the module's execution will be saved and can be later retrieved using the \texttt{ssc\_module\_log(...)} function, which is described subsequently in detail in Section~\ref{sec_messages}.  Alternatively, if the goal is simply to obtain information about the input and output variables associated with a module as in Section~\ref{sec_variable_docs}, the module must be explicitly instantiated also.

The next section describes a mechanism for running compute modules and providing real-time progress updates, reporting messages as they occur, and canceling a module's execution before it has finished.

\subsection{Running with Progress Updates, Warnings, and Errors}

The last (most complex) way to run a module is to provide a special function that can handles error and warning messages as they are generated, as well as provide progress updates to the controlling host software.  To accomplish this, the client code must provide a \emph{handler} (aka \emph{callback}) function to SSC.  The handler function must have the signature below.

\begin{verbatimtab}
ssc_bool_t (*handler)( ssc_module_t module, 
	ssc_handler_t handle, 
	int action, 
	float f0, 
	float f1, 
	const char *s0, 
	const char *s1, 
	void *user_data );
\end{verbatimtab}


\notebox{This module invocation method is only supported in the native C language API for SSC.  The other programming language interfaces provided with SSC (MATLAB, Python, C\#, Java) do not support callback functions via the foreign-function-interface (FFI) wrappers.  However, log messages (notices, warnings, errors) can still be retrieved after a simulation is completed using the \texttt{ssc\_module\_log()} function (see \S\ref{sec_messages}), although real-time progress updates cannot be issued.}

Supposing that such a function named \texttt{my\_ssc\_handler\_function()} has been defined, used the \texttt{ssc\_module\_exec\_with\_handler()} function to run the module.  You may pass an a generic data pointer to the function also, so that within the context of the handler the messages or progress updates can be routed accordingly.

\begin{verbatimtab}[4]
void *my_data = <some user data to send to the callback, or NULL>;

if ( ssc_module_exec_with_handler( module, data, my_ssc_handler_function, my_data ) )
	printf("success!\n");
else
	printf("fail!\n");
\end{verbatimtab}

The code below represents the default handler built into SSC.  Note that the handler function must return a boolean (0/1) value to indicate to SSC whether to continue simulating or not.  This provides the option to abort the simulation if a user has clicked a cancel button in the meantime, or similar.  The various parameters are used to convey SSC status information to the handler, and have different meanings (and data) depending on the \texttt{action\_type} parameter.

\begin{verbatimtab}[4]
static ssc_bool_t default_internal_handler( ssc_module_t p_mod, ssc_handler_t p_handler,
	int action_type, float f0, float f1, 
	const char *s0, const char *s1,
	void *user_data )
{
	if (action_type == SSC_LOG)
	{
		// print log messages to console
		std::cout << "Log ";
		switch( (int)f0 ) // determines type
		{
		case SSC_NOTICE: 
			std::cout << "Notice: " << s0 << " time " << f1 << std::endl; 
			break;
		case SSC_WARNING: 
			std::cout << "Warning: " << s0 << " time " << f1 << std::endl; 
			break;
		case SSC_ERROR: 
			std::cout << "Error: " << s0 << " time " << f1 << std::endl; 
			break;
		default: 
			std::cout << "Unknown: " << f0 << " time " << f1 << std::endl; 
			break;
		}
		return 1;
	}
	else if (action_type == SSC_UPDATE)
	{
		// print status update to console
		std::cout << "Progress " << f0 << "%:" << s1 << " time " << f1 << std::endl;
		return 1; // return 0 to abort simulation as needed.
	}
	else
		return 0;
}
\end{verbatimtab}

As noted in previous sections, the default handler simply prints warnings, errors, and simulation progress updates to the standard output stream on the console.  To implement a custom handler, it is recommended to copy the structure of the handler above, but to replace the output to the console with specialized handling for the messages and progress.  For example, in a graphical user interface program, the \texttt{user\_data} pointer could be used to pass in a pointer to a dialog class containing a progress bar and a text box.  The messages could be sent to the text box, and the progress bar updated appropriately.  The custom SSC handler function implemented in the graphical SSCdev tool (based on the excellent wxWidgets GUI library) is reproduced below, showing how messages and progess can be reported to the user.

\begin{verbatimtab}[4]
static ssc_bool_t my_handler( ssc_module_t p_mod, ssc_handler_t p_handler, int action, 
	float f0, float f1, const char *s0, const char *s1, void *user_data )
{
	wxProgressDialog *dlg = (wxProgressDialog*) user_data;
	if (action == SSC_LOG)
	{
		wxString msg;

		switch( (int)f0 )
		{
		case SSC_NOTICE: msg << "Notice: " << s0 << " time " << f1; break;
		case SSC_WARNING: msg << "Warning: " << s0 << " time " << f1; break;
		case SSC_ERROR: msg << "Error: " << s0 << " time " << f1; break;
		default: msg << "Unknown: " << f0 << " time " << f1; break;
		}

		// post the SSC message on the application-wide log window 
		app_frame->Log(msg);

		return 1;
	}
	else if (action == SSC_UPDATE)
	{
 		// update progress dialog with percentage complete
		dlg->Update( (int) f0, s0 );
		wxGetApp().Yield(true);

		return 1; // return 0 to abort simulation as needed.
	}
	else
		return 0; // invalid action
}
\end{verbatimtab}

The return value of the handler function is checked by compute modules to determine whether the calculations should proceed.  In the example above, no facility is provided for canceling a simulation as the handler function always returns 1 (true).  However, a dialog box with a cancel button could set a flag in the user data structure when pressed.  If the cancel flag is set to true, the handler function could return 0 (false) to abort the simulation.  It is left as an exercise to the user to implement such functionality in their host program.

\subsection{Retrieving Messages}
\label{sec_messages}

During simulation, a module may generate any number of (hopefully) informative messages about warnings or errors encountered.  The custom handler approach allows these messages to be reported to the user as the simulation progresses, but they are also stored in the module for retrieval later.  The \texttt{ssc\_module\_log()} function allows the client code to retrieve all the messages, regardless of which execute function was used to run the module.  Example:

\begin{verbatimtab}[4]
const char *text;
int type;
float time;
int index = 0;
while( (text = ssc_module_log( module, index++, &type, &time )) )
{
	switch( type ) // determines type
	{
	case SSC_NOTICE: 
		std::cout << "Notice: " << text << " time " << time << std::endl; 
		break;
	case SSC_WARNING: 
		std::cout << "Warning: " << text << " time " << time << std::endl; 
		break;
	case SSC_ERROR: 
		std::cout << "Error: " << text << " time " << time << std::endl; 
		break;
	default: 
		std::cout << "Unknown: " << text << " time " << time << std::endl; 
		break;
	}
}
\end{verbatimtab}

In essence, the \texttt{ssc\_module\_log()} is called repeatedly with an increasing index number until the function returns \texttt{NULL}, indicating that there are no more messages.  Along with the text of the message, information about the type (notice, warning, error) and the time that it was issued by the module are reported.

\notebox{Do not free the C string returned by \texttt{ssc\_module\_log()}.  It is a reference to internally managed memory.}


\subsection{Querying SSC for Available Modules}
\label{sec_modules_querying}

SSC provides a programming interface by which the library can be queried about all of the modules contained within it.  The example below prints all of the available modules to the console along with their version numbers and descriptions:

\begin{verbatimtab}[4]
ssc_entry_t entry;
int index = 0;
while( entry = ssc_module_entry( index++ ) )
{
	const char *module_name = ssc_entry_name( entry );
	const char *description = ssc_entry_desc( entry );
	int version = ssc_entry_version( entry );

	printf( "Module %s, version %d: %s\n", module_name, version, description );
}
\end{verbatimtab}

\section{Version Information}

Functions are included in SSC to return version information and details about the particular build.  For example:

\begin{verbatimtab}[4]
int version = ssc_version();
const char *build = ssc_build_info();

printf( "ssc version %d: %s\n", version, build );
\end{verbatimtab}

On Windows, this code may print:

\begin{verbatimtab}[4]
	ssc version 22: Windows 32 bit Visual C++ Nov 13 2012 18:44:14
\end{verbatimtab}

On Linux, a newer version of SSC may report something like:
\begin{verbatimtab}[4]
	ssc version 24: Unix 64 bit GNU/C++ Dec  5 2012 11:42:51
\end{verbatimtab}

\section{SSCdev}
\label{sec_sscdev}

SSCdev is the developer interface for SSC. It allows you to explore variables in the SSC modules, run individual modules, and write scripts to build and test your models. When you run modules in SSCdev, it displays all of the variables in the data container with their values.

Use SSCdev for the following tasks:

\begin{itemize}
\item Learn how modules you plan to use in your model work before before you start programming.
\item Troubleshoot problems with your implementation of SSC modules.
\item Build and test models in the LK script using the SSCdev script editor.
\end{itemize}

\subsection{Using SSCdev}
\label{sec_sscdev_get_started}

Using SSCdev involves running the executable, and loading the appropriate SSC library:

\begin{enumerate}
\item Run the executable file shown in Table \ref{ssc_dev_table_versions} for your operating system. For example, the 32-bit Windows executable \texttt{sscdev32.exe} is in the \texttt{win32} directory of the SDK package.
\item On the \textbf{File} menu, click \textbf{Choose SSC library}. Be sure to choose the correct library for your version of SSCdev. For example, for 32-bit Windows, choose the \texttt{ssc32.dll} library.

A list of modules should appear in the module browser, and the library path and name should appear in the status bar at the bottom of the SSCdev window. If the module browser is empty, try choosing the SSC library again.
\item Click a module's name to see its variables. For example, click \texttt{pvwattsv1} to see a list of the PVWatts module's 46 variables.
\end{enumerate}

\notebox{To see the SSCdev version information, on the \textbf{Help} menu, click \textbf{About}.}

\begin{table}
  \begin{center}
    \begin{tabular}{cccc}
       \hline
       Operating System & Directory Name & SSCdev Version & Library \\
       \hline
       Windows 32-bit & win32 & sscdev32.exe & ssc32.dll \\
       Windows 64-bit & win32 & sscdev64.exe & ssc64.dll \\
       OS X 64-bit & osx64 & sscdev.app & ssc64.dylib \\
       Linux 64-bit & linux64 & sscdev64.bin & ssc64.so \\ 
      \hline
    \end{tabular}
    \caption{SSCdev and Library Versions}\label{ssc_dev_table_versions}
  \end{center}
\end{table}

SSCdev displays a list of available modules, and lists each module's input and output variables, but does not provide enough information to completely understand the modules. You should be prepared to use the SAM user interface and documentation together with SSCdev to help you understand how the modules and variables work. 

For example, the \texttt{annualoutput} module includes a variable named \texttt{energy\_availability} that uses the data type \texttt{SSC\_ARRAY}. Why is the data type not \texttt{SSC\_NUMBER} instead? To find out, we can examine the \texttt{annualoutput} input variables in SAM's user interface, which displays them on the Performance Adjustment input page. The \texttt{energy\_availabilty} variable appears with the label ``Percent of annual output,'' and SAM provides two options for entering the variable's value: As a single value or as an annual schedule. The array data type is necessary to store the annual values. The \texttt{annualoutput} module assumes that if there is a single non-zero value at the top of the array, that value represents a single adjustment factor that applies to all years. Otherwise it applies values from the array to each year.

For some variables, even the SAM user interface may not be helpful. When you need help with an SSC module or variable, ask a question as a comment on the SAM website's SDK page. For example, you might wonder what the \texttt{annualoutput} module's \texttt{system\_use\_lifetime\_output} variable does. That variable is not on any of SAM's input pages, and the information in SSCdev does not explain its function. The variable determines whether the module generates a single set of 8,760 hourly values for the \texttt{hourly\_e\_net\_delivered} variable, or whether it generates a set of 8,760 values for each year in the analysis period. All of SAM's performance models use a value of zero except for the geothermal model, which is a special case and requires lifecycle output data to accurately represent changes in resource over time as it is depleted and replenished. For most cases, you should set its value to zero.

\subsection{SSCdev Menus}
\label{sec_sscdev_menus}

\textbf{File}
\begin{quote}
\begin{description}
\item[Start simulation] Runs the active module in the module browser.
\item[Load/unload SSC library] Loads or unloads the current SSC library for troubleshooting. If a module does not run, you can try unloading and reloading the library.
\item[Choose SSC library] Displays a file dialog where you can choose and load the SSC library. Be sure to choose the correct library for your version of SSCdev.
\item[Load data file] Open a data container file. (\texttt{.bdat}).
\item[Save data file] Save the data container to a file. (\texttt{.bdat}).
\item[Recent files] Display a list of recent data (\texttt{.bdat}) and script (\texttt{.lk}) files.
\item[Exit] Quit SSCdev.
\end{description}
\end{quote}

\textbf{Script}

The Script menu commands duplicate the buttons in the Script Editor. They are implemented as menu items to make the shortcut keys available.

\begin{quote}
\begin{description}
\item[Open] Open a script file (\texttt{.lk}).
\item[Save] Save the current script.
\item[Find] Find text in the current script.
\item[Find next] Find the next instance of a text string in the current string.
\item[Run script] Run the current script. 
\end{description}
\end{quote}

\textbf{Help}

The \textbf{About} command displays information about the current version of SSCdev.

\subsection{Module Browser}
\label{sec_sscdev_module_browser}

The module browser displays the modules available in the current SSC library. When you choose a module from the list, it also shows a list of the module's variables. It can:

\begin{itemize}
\item Display a list of available SSC modules.
\item Display module variables.
\item Copy a tab-delimited list of a module's variables to your computer's clipboard.
\item Run a single module using variable values defined in the data container.
\end{itemize}

\notebox{If the module browser is empty, check the status bar at the bottom of the SSCdev window to see whether the correct SSCdev library is loaded. See Section \ref{sec_sscdev_get_started} for instructions to load a library.}

You can use the module browser as a reference while you are developing your model to help ensure that you assign values to all of the required input variables, and use the correct data types and units.

You can also use the module browser with the data container to manually set values of input variables and run modules individually. This might be useful for learning how a module works, or for troubleshooting your model's implementation of a module.

\subsubsection{Run a Simulation from the Module Browser}
\label{sec_sscdev_module_browser_run_module}

To run a simulation from the module browser, choose a module from the list and click \textbf{Run}. SSCdev displays information about the simulation in the notification pane.

\subsection{Data Container}
\label{sec_sscdev_data_container}

The data container displays a list of variables for the current set of simulations. When you run a module from the data browser, you must add input variables to the data container by hand using the \textbf{Add} and \textbf{Edit} buttons. When you run modules from the script editor, the data container is automatically populated with variables from the script. You can use the data container commands for the following tasks:

\begin{itemize}
\item Add, edit, and remove variables from the data container.
\item Copy a tab-delimited list of variable names and values to your computer's clipboard.
\item Show graphs of time series data.
\end{itemize}

The data container commands act either on the current variable indicated with a blue highlight, or on selected variables indicated by a check mark:

\begin{quote}
\begin{description}
\item[Add] Add a variable to the data container. If you add a module's input variable to the data container, be sure to use the variable's exact name and data type shown in the module browser.
\item[Edit] Change the current variable's name, data type, or value.
\item[Delete] Remove the current variable from the data container.
\item[Del checked] Remove all selected variables from the data container.
\item[Del unchecked] Remove all variables without check marks from the data container.
\item[Del all] Delete all variables from the data container.
\item[Select all]  Select (check) all variables in the data container. This command may take several seconds to complete.
\item[Unselect all] Clear all variables in the data container.
\item[Copy to clipboard] Copy a tab-delimited list of selected variables and their values to the clipboard.
\item[Show stats] Displays statistical summary data for variables of type \texttt{SSC\_ARRAY}. It is intended to display the annual and monthly minimum, maximum, mean, total, and total divided by 1000 of a data set representing time steps over a single year.
\notebox{You can copy data from the monthly table by selecting the text and pressing the copy-to-clipboard shortcut keys for your computer (Ctrl-C in Windows).}
\item[Timeseries graph] Display graphs of all selected variables with 8,760 values in the time series data viewer.
\end{description}
\end{quote}

\notebox{If you manually add variables to the data container before running a script that does not use the variables, they will be deleted from the data container.}

\subsection{Script Editor}
\label{sec_sscdev_script_editor}

The script editor allows you to write, edit, and run scripts in the LK scripting language to build and test models using the SSC modules.

The script editor commands are:

\begin{quote}
\begin{description}
\item[New] Clear the current script from the script editor.
\item[Open]  (\textbf{Ctrl-O}) Open a script file (\texttt{.lk}).
\item[Save] (\textbf{Ctrl-S}) Save the current script file (\texttt{.lk}).
\item[Save as] Save the current script to a different file (\texttt{.lk}).
\item[Find] (\textbf{Ctrl-F}) Find text in the current script.
\item[Find next] (\textbf{F3}) Find the next instance of text in the current script.
\item[Help] Display a list of script functions.
\item[Run] (\textbf{F5}) Run the current script.
\end{description}
\end{quote}

\subsection{SSCdev Example 1: Run a Simulation Module without Scripting}
\label{sec_sscdev_example_no_scripting}

The following example shows how to use the module browser to expore and run the \texttt{pvwattsv1} module. You can use the same steps to explore other simulation modules.

\notebox{As described in Section \ref{??ref:sscdev overview}, the module browser can only a single simulation module at a time. It can not combine modules to build a model as described in Section \ref{??ref:sscdev build model in script"}.}

As we saw in Section \ref{??ref:overview}, the \texttt{pvwattsv1} simulation module reads data from a weather file and inputs that define the system's size, array orientation and type of tracking, and derating factor, and calculates values for the 1 by 8760 array storing the system's hourly electricity output over a single year. 

To explore the \texttt{pvwattsv1} simulation module in the module browser:

\begin{enumerate}
\item Start SSCdev as described in Section \ref{??ref:overview}

\item On the \textbf{Module Browser} tab, click the \texttt{pvwattsv1} name to see a list of the module's variables. The inputs are of type (SSC\_INPUT). Of the inputs, only a subset indicated by (\texttt{*}) are required with no default values, as described in Section~\ref{sec_def_const}.

\item Press the \textbf{F6} key to start simulations. Nothing happens because you have to choose a module to run it.

\item In the drop-down list under the list of available modules, choose the \texttt{pvwatts1} module and press \textbf{F5} again, or click \textbf{Run}.

This time, a message about the \texttt{file\_name} variable appears in the SSCdev notification panel. That is because \texttt{file\_name} is a required variable, but it does not yet have a value.

\item In the variable viewer, click \textbf{Add}, and type \textit{file\_name} for the variable name, assign it the \texttt{SSC\_STRING} data type, and click \textbf{file} to assign it the value of one of the TMY2 files included in the SDK Examples folder (for example, \textit{daggett.tm2}).

\item Next, add the remaining 5 required variables shown in the module browser, using the data type and units shown in the table. For example, \texttt{system\_size} should be \texttt{SSC\_NUMBER} with a value in kilowatts. Be sure to use variable names and data types that exactly match those in the module browser.
\end{enumerate}

When you are finished, you should see a table similar to Table \ref{table_ssc_dev_a}. This is the model's data container, which so far contains the input and output variables for the \texttt{pvwattsv1} simulation module.

\begin{table}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
file\_name & system\_size & derate & track\_mode & azimuth & tilt\\
\hline
F:/SSC/examples/daggett.tm2 & 4.000000 & 0.860000 & 1.000000 & 180.000000 & 25.000000\\
\hline
\end{tabular}
\caption{The 6 required input variables for the pvwattsv1 module with their values}\label{table_ssc_dev_a}
\end{table}

\subsection{SSCdev Example 2: Use a Script to Build a Model}
\label{sec_sscdev_example_no_scripting}

\section{Language Interfaces}

The SSC software development kit (SDK) includes interfaces for using SSC directly from programming languages other than its native C language interface.  This section describes each language interface's system and software requirements, as well any limitations in functionality compared with the native C interface.

\subsection{Python}
Python is a popular object-oriented scripting language that is either interpreted directly from source code or compiled into an intermediate bytecode.  Most installations of the Python interpreter include the \emph{Ctypes} package, which provides a \emph{foreign function interface (FFI)} capability for directly utilizing dynamic libraries.

The Python language interface has been tested on Windows using the popular ActivePython distribution, as well as on Linux and OSX using the pre-installed Python packages.

The Python API is defined in the \texttt{sscapi.py} source file included in the SDK.  The file includes example code if it is invoked as the main souce program.

\notebox{In the PySSC class constructor, a \emph{Ctypes} object is created by referencing the \texttt{ssc.dll} dynamic library.  It is up to the user to modify the file name and/or path of this library to be appropriate for the operating system and platform.}

The structure of SSC API calls in Python is slightly different from the C interface, since an instance of the PySSC class must be created first.  Example:

\begin{verbatimtab}[4]
	ssc = PySSC()
	dat = ssc.data_create()

	ssc.data_set_string(dat, 'file_name', 'daggett.tm2')
	ssc.data_set_number(dat, 'system_size', 4)
	ssc.data_set_number(dat, 'derate', 0.77)
	ssc.data_set_number(dat, 'track_mode', 0)
	ssc.data_set_number(dat, 'azimuth', 180)
	ssc.data_set_number(dat, 'tilt_eq_lat', 1)

	# run PV system simulation
	mod = ssc.module_create("pvwattsv1")

	if ssc.module_exec(mod, dat) == 0:
		print 'PVWatts V1 simulation error'
		idx = 1
		msg = ssc.module_log(mod, 0)
		while (msg != None):
			print '\t: ' + msg
			msg = ssc.module_log(mod, idx)
			idx = idx + 1
	else:
		ann = 0
		ac = ssc.data_get_array(dat, "ac")
		for i in range(len(ac)):
			ac[i] = ac[i]/1000
			ann += ac[i]
		print 'PVWatts V1 Simulation ok, e_net (annual kW)=', ann
		ssc.data_set_array(dat, "e_with_system", ac) # copy over ac

	ssc.module_free(mod)

	ssc.data_free( dat )
\end{verbatimtab}

Notice that the structure of creating and freeing data containers and modules is identical to the C language API, except that the functions are members of the PySSC class.  For more information, peruse the \texttt{sscapi.py} source file for additional examples and usage cases.

\subsection{MATLAB}

MATLAB is a numerical computing language that is widely used for data processing, algorithm development, and plotting.  It is a proprietary product that is available on OSX, Linux, and Windows.  

The SSC MATLAB interface has been tested with MATLAB 7.5 (2007b) 32-bit on Windows.  The built-in MATLAB \emph{foreign function interface (FFI)} library routines that are used to interface to SSC require a C compiler to be installed on the computer alongside MATLAB to automatically preprocess the SSC header file.  Some versions of MATLAB include a C compiler such as LCC installed by default, while other versions and/or platforms may require one to be installed separately.  See \texttt{http://www.mathworks.com/support/compilers/R2012b/win64.html} for more information.

The SSC API is provided in the \texttt{ssccall.m} M-file.  The interface provides a single MATLAB function called \texttt{ssccall(...)} that accepts different parameter arguments to invoke the various SSC library calls.  The example below shows how to setup and run the \emph{pvwattsv1} module from MATLAB.

\begin{verbatimtab}[4]
ssccall('load');

% create a data container to store all the variables
data = ssccall('data_create');

% setup the system parameters
ssccall('data_set_string', data, 'file_name', 'abilene.tm2');
ssccall('data_set_number', data, 'system_size', 4);
ssccall('data_set_number', data, 'derate', 0.77);
ssccall('data_set_number', data, 'track_mode', 0);
ssccall('data_set_number', data, 'tilt', 30);
ssccall('data_set_number', data, 'azimuth', 180);

% create the PVWatts module
module = ssccall('module_create', 'pvwattsv1');

% run the module
ok = ssccall('module_exec', module, data);
if ok,
    % if successful, retrieve the hourly AC generation data and print
    % annual kWh on the screen
    ac = ssccall('data_get_array', data, 'ac');
    disp(sprintf('pvwatts: %.2f kWh',sum(ac)/1000.0));
else
    % if it failed, print all the errors
    disp('pvwattsv1 errors:');
    ii=0;
    while 1,
        err = ssccall('module_log', module, ii);
        if strcmp(err,''),
            break;
        end
        disp( err );
        ii=ii+1;
    end
end

% free the PVWatts module that we created
ssccall('module_free', module);

% release the data container and all of its variables
ssccall('data_free', data);

% unload the library
ssccall('unload');
\end{verbatimtab}

The MATLAB language interface automatically attempts to detect the platform and load the correct SSC dynamic library.  You must ensure that the \texttt{sscapi.h} C language header file can be located by MATLAB, as well as the library appropriate for your system.  

For additional information, consult the MATLAB code examples supplied with the SSC SDK, as well as the content of the \texttt{ssccall.m} file itself.

\subsection{C\# and .NET}

The C\# language interface provides direct access to the SSC library from the Microsoft .NET software environment.  C\# is an object-oriented garbage-collected language that is compiled typically to an intermediate bytecode that is executed in a managed environment by the bytecode interpreter engine.  Objects and memory are directly managed by the interpreter, relieving programmers of the burdens of detailed memory management.  However, since SSC is implemented at its core in a native compiled machine code library, care must be taken by the typical C\# programmer to ensure that the interface to the unmanaged SSC library is properly utilized.

The C\# SSC language interface is provided as a single source file called \texttt{SSC.cs}.  This file contains direct invocation mappings to the unmanaged C library API, as well as an easy-to-use wrapper around the low-level function calls.  This API has been tested using Visual Studio 2012 .NET on Win32 and x64.  .NET implementations on other platforms such as Mono have not been tested.

To call the SSC library from C\#, include the \texttt{SSC.cs} file in your .NET project in Visual Studio. For each opaque data pointer type in the SSC native C API, there is a similarly named C\# class within the SSC namespace.  See the example below on how to create a data container and module to run PVWatts.  Additional examples of the other SSC API functions using the C\# wrapper classes is available in the included test program in the SDK.

\begin{verbatimtab}[4]
private void btnPVWatts_Click(object sender, EventArgs e)
{
	txtData.Clear();

	SSC.Data data = new SSC.Data();

	data.SetString("file_name", "abilene.tm2");
	data.SetNumber("system_size", 4.0f);
	data.SetNumber("derate", 0.77f);
	data.SetNumber("track_mode", 0);
	data.SetNumber("tilt", 20);
	data.SetNumber("azimuth", 180);

	SSC.Module mod = new SSC.Module("pvwattsv1");

	if (mod.Exec(data))
	{
		float tot = data.GetNumber("ac_annual");
		float[] ac = data.GetArray("ac_monthly");
		for (int i = 0; i < ac.Count(); i++)
			txtData.AppendText("[" + i + "]: " + ac[i] + " kWh\n");
		txtData.AppendText("AC total: " + tot + "\n");
		txtData.AppendText("PVWatts test OK\n");
	}
	else
	{
		int idx = 0;
		String msg;
		int type;
		float time;
		while (mod.Log(idx, out msg, out type, out time))
		{
			String stype = "NOTICE";
			if (type == SSC.API.WARNING) stype = "WARNING";
			else if (type == SSC.API.ERROR) stype = "ERROR";

			txtData.AppendText("[ " + stype + " at time:" + time + " ]: " + msg + "\n");
			idx++;
		}

		txtData.AppendText("PVWatts example failed\n");
	}
}


\end{verbatimtab}

\notebox{The SSC C\# class library is designed to properly handle allocation and freeing of underlying native SSC data types.  However, due to the nature of the .NET runtime environment's garbage collector, it may appear that SSC objects are not freed right away.  While it is possible to invoke the garbage collector manually, it is generally not recommended to do so by the Visual Studio documentation.}

For more information, consult the \texttt{SSC.cs} source file, as well as the example Visual Studio project provided with the SDK.

\subsection{Java}

The Java interface to SSC utilizes the low-level Java Native Interface (JNI) specification to directly access the SSC library.  The JNI wrapper consists of a C source file \texttt{jssc.c} that wraps the SSC native C language API into JNI methods that can be compiled and loaded by the Java Virtual Machine (JVM) at runtime.  The source code for the JNI wrapper is included in the SDK, as well as a more programmer-friendly high-level Java \texttt{SSC} class that invokes the JNI layer.

The JNI interface marshals opaque C pointers as the 64-bit \texttt{jlong} data type, ensuring compatibility in both 32 and 64 bit implementations.

Compiling the JNI interface layer requires a C compiler and the Java SDK (for the JNI header files).  The example included with the SSC SDK was tested using the freely downloadable MinGW gcc compiler on 32-bit Windows (\texttt{https://www.mingw.org}), and the Java JDK 1.7.  Refer to the \texttt{README.txt} in the \texttt{[sdk]/languages/java/} folder for specific information on compiling the JNI interface layers for your particular SDK runtime environment.

Once the JNI wrapper library has been compiled for your particular JDK version, the PVWatts example can be invoked from within Java as below:

\begin{verbatimtab}[4]

public class SSC_Java_Example {
   
    public static void main(String[] args)
    {
        System.loadLibrary("sscapiJNI32");
		
        SSC sscobj = new SSC("pvwattsv1");

        sscobj.Set_String("file_name", "abilene.tm2" );
        sscobj.Set_Number("system_size", 4.0f );
        sscobj.Set_Number("derate", 0.77f );
        sscobj.Set_Number("track_mode", 0 );
        sscobj.Set_Number("tilt", 20 );
        sscobj.Set_Number("azimuth", 180 );
        
		if ( sscobj.Exec() )
        {
            float[] ac = sscobj.Get_Array( "ac" );
            float sum = 0;
            for( int i=0;ac.length;i++)
            {
                sum += ac[i];
            }
            System.out.println("ac total: " + sum);
            System.out.println("PVWatts example passed");
        }
        else
        {
            System.out.println("PVWatts example failed");
        }
    }    
}

\end{verbatimtab}

For more information on utilizing the Java language layer, consult Java code examples provided in the SDK.  


\section{C API Reference}
\label{sec_api_ref}
\include{ssc_api_latex/sscapi_8h}

\section{Legal}

The System Advisor Model (``Model'') is provided by the National Renewable Energy Laboratory (``NREL''), which is operated by the Alliance for Sustainable Energy, LLC (``Alliance'') for the U.S. Department Of Energy (``DOE'') and may be used for any purpose whatsoever.  

The names DOE/NREL/ALLIANCE shall not be used in any representation, advertising, publicity or other manner whatsoever to endorse or promote any entity that adopts or uses the Model.  DOE/NREL/ALLIANCE shall not provide any support, consulting, training or assistance of any kind with regard to the use of the Model or any updates, revisions or new versions of the Model.

YOU AGREE TO INDEMNIFY DOE/NREL/ALLIANCE, AND ITS AFFILIATES, OFFICERS, AGENTS, AND EMPLOYEES AGAINST ANY CLAIM OR DEMAND, INCLUDING REASONABLE ATTORNEYS' FEES, RELATED TO YOUR USE, RELIANCE, OR ADOPTION OF THE MODEL FOR ANY PURPOSE WHATSOEVER.  THE MODEL IS PROVIDED BY DOE/NREL/ALLIANCE "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY DISCLAIMED.  IN NO EVENT SHALL DOE/NREL/ALLIANCE BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER, INCLUDING BUT NOT LIMITED TO CLAIMS ASSOCIATED WITH THE LOSS OF DATA OR PROFITS, WHICH MAY RESULT FROM ANY ACTION IN CONTRACT, NEGLIGENCE OR OTHER TORTIOUS CLAIM THAT ARISES OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THE MODEL.


\end{document}
