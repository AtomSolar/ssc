\documentclass{article}
\usepackage{geometry} 
\geometry{letterpaper} 
%%%% Uncomment below to begin paragraphs with an empty line %%%%
\usepackage[parfill]{parskip} 
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{moreverb}
%\usepackage[section]{placeins}
%\usepackage[below]{placeins}
\usepackage{epstopdf}
%\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\newcommand\bslash{\char`\\}
\newcommand\lt{\char`\<}
\newcommand\gt{\char`\>}
\newcommand{\tab}{\hspace*{2em}}
\newcommand{\supers}[1]{\ensuremath{^\textrm{{\scriptsize #1}}}}
\newcommand{\subs}[1]{\ensuremath{_\textrm{{\scriptsize #1}}}}
\newcommand{\notebox}[1]{ \begin{center}\framebox[5.5in]{\begin{minipage}[t]{5.0in}\textbf{Note: }#1\end{minipage}}\end{center}}

\title{SSC Reference Manual}
\author{Aron P. Dobos}

\begin{document}

\maketitle
\vspace{3in}
\begin{abstract}
The SSC (SAM Simulation Core) software library implements the underlying renewable energy system modeling calculation engine utilitized by the popular desktop System Advisor Model (SAM) tool.  SSC provides a simple and programmer-friendly application programming interface (API) that allows developers to directly integrate SAM calculations into other tools.  The API includes mechanisms to set input variable values, run simulations, and retrieve calculated outputs.  The library is provided to users as pre-compiled binary dynamic libraries for Windows, Mac OSX, and Linux, with the bare minimum system library dependencies.  While the native API language is ISO-standard C, language bindings for MATLAB, and Python are included.  The API and model implementations are thread-safe and reentrant, allowing the software to be efficiently utilized in a parallel computing environment.

This document describes the software architecture of SSC, introduces the SSC Development Environment tool, explains how to set up simulations from code, query the library for variable information, and provides examples and ``case studies" in various programming languages to ease the adoption of SSC into other systems.  

\textbf{Note.} The reader is assumed to have familiarity with the C programming language, as well as some level of proficiency using the System Advisor Model (SAM) tool.
\end{abstract} 

\newpage
\tableofcontents
%%\listoffigures
%%\listoftables
\newpage

\section{Overview}
\label{sec_overview}

The SSC software library provides a standard interface through which complex engineering and economic models of renewable energy systems can be configured and invoked.  The System Advisor Model (SAM) desktop application is essentially a user-friendly front-end for SSC, and uses SSC to perform all system performance and financial calculations.  It is assumed that the reader is well versed in SAM, its suite of models, typical inputs and outputs, and general usage.

\subsection{Framework Description}

SSC is designed as a general simulation framework that is model agnostic.  For example, there is no specific \texttt{pvwatts(...)} function call in the API that accepts model parameters and returns a calculated result.  Rather, a generic mechanism is provided for sending a model data, running the model, and retrieving results from it.  

The standard way to invoke a model in SSC involves three steps:

\begin{enumerate}
\item A generic data container is populated by the user with named variables and their values.  These variables are inputs to the model.
\item A particular model (like \texttt{pvwattsv1}) is selected to \emph{process} the data container.  The model may run successfully using the input variables defined by the user, or fail with error messages.  If the model succeeds, it populates the data container with the calculated output variables.
\item Calculated outputs are retrieved from the data container, or error messages are retrieved.
\end{enumerate}

Essentially, this sequence is no different than calling a function in a programming language.  Step~1 can be thought of as passing parameters to the function, step~2 as running the function, and step~3 as getting the calculated result returned.  In SSC, the ``function'' is called a \emph{module}, and the data container is simply \emph{data}.  The \emph{module} operates on the \emph{data} and transforms it by calculating new variables and adding them to the dataset.  In the API, these are represented by the \texttt{ssc\_module\_t} and \texttt{ssc\_data\_t} types, which will be covered in detail later.

\subsection{Modeling Systems}

Different modules are available in SSC for each type of simulation possible in SAM.  A sample of modules is shown in Table~\ref{tab_sample_modules}.


\begin{table}[ht]
\begin{center}
\begin{tabular}{ll}
Module & Description \\
\hline
\texttt{pvwattsv1} & Implements the NREL PVWatts model for PV performance\\
\texttt{pvsamv1} & Implements the component-based PV models in SAM\\
\texttt{wfreader} & Reads standard format weather data files (TM2, TM3, EPW, SMW)\\
\texttt{irradproc} & General purpose irradiance processor for calculating POA\\
\texttt{windpower} & Implements the NREL wind turbine and simple wind farm model\\
\texttt{cashloan} & Implements residential and commercial cashflow economic model\\
\texttt{ippppa} & Commercial PPA and Independent Power Producer (IPP) financial models\\
\texttt{annualoutput} & Calculates degraded out-years system output for the analysis period\\
\texttt{utilityrate} & Calculates the value of energy using complex utility rate structures\\
\end{tabular}
\caption{Some commonly used SSC modules}
\label{tab_sample_modules}
\end{center}
\end{table}

To perform a complete technoeconomic systems analysis, multiple compute modules can be called in succession.  For example, when the PVWatts+Residential configuration is selected in SAM, several compute modules are called in to perform the calculation, as listed below.

\begin{enumerate}
\item \texttt{pvwattsv1}: The system parameters are used to calculate the hourly PV system performance.
\item \texttt{annualoutput}: The availability and degradation factors are applied to the annual energy output for the duration of the specified analysis period.
\item \texttt{utilityrate}: The value of the generated energy is calculated given the specifics of the complex utility rate structure, and the first year's hourly energy value is reported, along with the annual total value of energy at each year of the analysis period.
\item \texttt{cashloan}: Given the amount of the energy produced each year and the dollar value of this energy, this module calculates the cost of energy, net present value, and other metrics of the system based on specified system cost, incentives, operation and maintainance costs, taxes, and loan parameters.
\end{enumerate}

In some cases, the output variables of one module have the right units and number of data values to feed directly into the next module in a sequence, but this is not enforced.  For example, the \texttt{pvwattsv1} module has an output variable \texttt{ac} which is the hourly energy in kWh produced by the system.   However, the \texttt{annualoutput} module requires an input with the name \texttt{energy\_net\_hourly}.  It is up to the user to ensure that variables are translated appropriately between the outputs of one module and the inputs of another, including any units conversions that may be necessary.  Luckily, SSC provides exhaustive documentation of all of the input variables required by a module and all of the outputs that will be calculated.  Working with input and output variables will be the topic of a subsequent chapter.

\section{A Basic Example: PVWatts}

In this section, we will write a simple command-line C program to calculate the monthly energy production of a 1 kW PV system at a particular location.  The complete source code for this example program is included with the SSC SDK in the file \texttt{example1\_pvwatts.c}.

\subsection{Program Skeleton}

The SSC API is defined a C header called \texttt{sscapi.h}, and this file must be included in your program before any SSC functions can be called.  We will assume that the weather file is specified as a command line argument, and is one of the types that the \texttt{pvwattsv1} can read (TM2, TM3, EPW, SMW).  The skeleton of our program might look like the listing below.

\begin{verbatimtab}[4]
#include <stdio.h>
#include "sscapi.h"

int main(int argc, char *argv[])
{
	if ( argc < 2 )
	{
		printf("usage: pvwatts.exe <weather-file>\n");
		return -1;
	}
 
	// run PVWatts simulation for the specified weather file
	
	return 0;
}
\end{verbatimtab}

\subsection{Setting up data inputs}

Now we will fill in the comment in the middle of the code step-by-step.  Referring to the three step process outlined in Section~\ref{sec_overview}, the first task is to create a data container.  This is done with the \texttt{ssc\_data\_create()} function call, which returns an \texttt{ssc\_data\_t} type.  If for some reason the function call fails due to the system having run out of memory, \texttt{NULL} will be returned.  It is important to check the result to make sure the data container was created successfully.

\begin{verbatimtab}
	ssc_data_t data = ssc_data_create();
	if ( data == NULL )
	{
		printf("error: out of memory.\n");
		return -1;
	}
\end{verbatimtab}

Next, we assign the input variables required by the \texttt{pvwattsv1} module.  In Section~\ref{chap_variables}, we will show how to obtain information about the data types, names, labels, and units of variables.  For now, it suffices to say that SSC supports data as numbers, text strings, arrays, matrices, and tables.

\begin{verbatimtab}
	ssc_data_set_string( data, "file_name", argv[1] ); // set the weather file name
	ssc_data_set_number( data, "system_size", 1.0f );  // system size of 1 kW DC
	ssc_data_set_number( data, "derate", 0.77f );      // system derate
	ssc_data_set_number( data, "track_mode", 0 );      // fixed tilt system
	ssc_data_set_number( data, "tilt", 20 );           // 20 degree tilt
	ssc_data_set_number( data, "azimuth", 180 );       // south facing (180 degrees)
\end{verbatimtab}

At this point, we have a data container with six variables that are the input parameters to the module that we wish to run.  

\subsection{Simulating and retrieving outputs}
\label{sec_ex_pvwatts_module}

Next, an instance of the module itself must be created, per below.  The name of the desired module must be passed to the \texttt{ssc\_module\_create()} function.  If the specified module name is not recognized, or the system is out of memory, the function may return \texttt{NULL}.

\begin{verbatimtab}
	ssc_module_t module = ssc_module_create( "pvwattsv1" );
	if ( NULL == module )
	{
		printf("error: could not create 'pvwattsv1' module.\n");
		ssc_data_free( data );
		return -1;
	}
\end{verbatimtab}

Next, the simulation must be run.  If all the required input variables have been defined in the data container and have appropriate data types and values, the simulation should finish successfully.  Otherwise, an error will be flagged.  

\begin{verbatimtab}
	if ( ssc_module_exec( module, data ) == 0 )
	{
		printf("error during simulation.\n");
		ssc_module_free( module );
		ssc_data_free( data );
		return -1;
	}
\end{verbatimtab}

By default, the \texttt{ssc\_module\_exec()} function prints any log or error messages to standard output on the console.  There is a more complex way to run a simulation that can reroute messages somewhere else, for example if a program wanted to pop up a message box or collect all messages and return them to the sure.  This will be discussed in later sections.

Assuming that the simulation succeeded, it is now time to extract the calculated results.  Modules may calculate hundreds of outputs, but for this example, we simply are interested in the total AC energy produced by the 1 kW PV system.  As it turns out, \texttt{pvwattsv1} only provides the hourly data, so it is up to us to sum up the hourly values.  The code snippet below shows how to query the data object for the \texttt{ac} variable and aggregate it.

\begin{verbatimtab}
	double ac_total = 0;
	int len = 0;
	ssc_number_t *ac = ssc_data_get_array( data, "ac", &len );
	if ( ac != NULL )
	{
		int i;
		for ( i=0; i<len; i++ )
			ac_total += ac[i];
		printf("ac: %lg kWh\n", ac_total*0.001 );
	}
	else
	{
		printf("variable 'ac' not found.\n");
	}
\end{verbatimtab}

\subsection{Cleaning up}

We're now finished simulating the PV system and retrieving the results.  To avoid filling up the computer's memory with unneeded data objects, it is important to free the memory when it is no longer needed.  To this end, the \texttt{ssc\_module\_free()} and \texttt{ssc\_data\_free()} functions are provided.  Note that after calling one of these functions, the \texttt{module} and \texttt{data} variables are invalidated and cannot be used unless reassigned to another or a new data object or module.

\begin{verbatimtab}	
	ssc_module_free( module );
	ssc_data_free( data );
\end{verbatimtab}

\subsection{Compiling and running}

Using the MinGW compiler toolchain on Windows, it is very straightforward to compile and run this example.  Simply issue the command below at the Windows command prompt (\texttt{cmd.exe} from Start/Run), assuming that the \texttt{sscapi.h} header file and 32-bit \texttt{ssc.dll} dynamic library is in the same folder as the source file.  The complete source code for this example is included in the SSC SDK.  This example was tested with MinGW gcc version 4.6.2.

\begin{verbatim}
c:\> gcc example1_pvwatts.c ssc.dll -o pvwatts.exe
\end{verbatim}

To run the program, specify a weather file on the command-line.  Here, we use TMY2 data for Daggett, CA, which is included in the SDK as \emph{daggett.tm2}.

\begin{verbatim}
c:\> pvwatts.exe daggett.tm2
ac: 1468.54 kWh
\end{verbatim}

If all goes well, the total annual AC kWh for the system is printed on the console.


\subsection{Some additional comments}

The \texttt{ssc\_data\_t} and \texttt{ssc\_module\_t} data types are opaque references to internally defined data structures.  The only proper way to interact with variables of these types is using the defined SSC function calls.  As listed in the \texttt{sscapi.h} header file, both are typedef'd as \texttt{void*}.


\section{Data Variables}
\label{sec_variables}

Simulation model inputs and outputs are stored in a data container of type \texttt{ssc\_data\_t}, which is simply a collection of named variables.  Internally, the data structure is an unordered map (hash table), permitted very fast lookup of variables by name.  Every input and output variable in SSC is designated a name, a \emph{variable type}, and a \emph{data type}, along with other meta data (labels, units, etc). 

The variable name is mechanism by which data are identified by SSC, and the user is required to supply input variables with names that SSC has predefined.  Names can contain letters, numbers, and underscores.  Although names can be defined with upper and lower case letters, SSC does not distinguish between them internally: hence \texttt{Beam\_Irradiance} is the same variable as \texttt{beam\_irradiance}.

\subsection{Variable Types}

The \emph{variable type} identifies each variable as an input, output, or in-out variable.  In the SSC API, these values are defined by the constants reproduced below.

\begin{verbatimtab}
#define SSC_INPUT 1
#define SSC_OUTPUT 2
#define SSC_INOUT 3
\end{verbatimtab}

Input variables are required to be set by the user before a module is called, while output variables are calculated by the module and assigned to the data container when the module has finished running.  In-out variables are supplied by the user before the model runs, and the model transforms the value in some fashion.

Note that from the perspective of the data container, inputs and outputs are stored without distinction in an equivalent manner.  Thus, it is impossible to tell simply from the contents of a data container whether a variable was an input or an output - it is just a pile of data.  It is only the simulation modules that specify the variable type.

\subsection{Data Types}

Every variable in SSC is assigned a particular data type, and each simulation module to specifies the data type of each variable required as input, as well as the data type of each output.  SSC can work with numbers, text strings, one-dimensional arrays, two-dimensional matrices, and tables.  The data type constants are listed below.

\begin{verbatimtab}
#define SSC_INVALID 0
#define SSC_STRING 1
#define SSC_NUMBER 2
#define SSC_ARRAY 3
#define SSC_MATRIX 4
#define SSC_TABLE 5
\end{verbatimtab}

All numbers are stored using the \texttt{ssc\_number\_t} data type.  By default, this is a typedef of the 32-bit floating point C data type (\texttt{float}).  The purpose of using \texttt{float} instead of the 64-bit \texttt{double} is to save memory.  While a simulation module may perform all of its calculations internally using 64-bit precision floating point, the inputs and results are transferred into and out of SSC using the smaller data type.

Arrays (1-D) and matrices (2-D) store numbers only - there is no provision for arrays or matrices of text strings, or arrays of tables.  Arrays and matrices are optimized for efficient storage and transfer of large amounts of numerical data.  For example, a photovoltaic system simulation at 1 second timesteps for a whole year would produce 525,600 data points, and potentially several such data vectors might be reported by a single simulation model.  This fact underscores the reasoning to use the 32-bit floating point data type: just 20 vectors of 525,600 values each would require 42 megabytes of computer memory.

SSC does not provision separate storage for integers and floating point values - all numbers are stored internally as floating point.  However, a module may specific a numeric input with the \emph{integer} constraint which is checked automatically before the module is run.  Constraints will be discussed later.

Text strings (\texttt{SSC\_STRING})  are stored as 8-bit characters.  SSC does not support multi-byte or wide-character string representations, and all variable names and labels use only the 7-bit ASCII Latin alphabet.  Consequently, text is stored as null ('\textbackslash 0') terminated \texttt{char*} C strings.  Weather file names are common input variables that use the \texttt{SSC\_STRING} data type.

The table (\texttt{SSC\_TABLE}) data type is the only hierarchical data type in SSC.  Essentially, it allows a simulation module to receive or return outputs in a structured format with named fields.  A table is nothing more than a named variable that is itself a data container, which can store any number of named variables of any SSC data type.  Currently, most SSC modules do not make heavy use of tables, but they are fully implemented and supported for future complex modules that may be added.

\subsection{Variable Documentation}

As stated before, each module defines all of the input variables it requires and output variables it produces.  Since SSC is a model simulation framework that contains within it numerous calculation modules that each may have hundreds of variables, it is impractical to separate to the documentation of variables from their definitions.  Otherwise, the documentation would tend to be consistently out of date as modules are updated and new ones are added.
\begin{table}[ht]
\begin{center}
\begin{tabular}{ll}
Field & Description\\
\hline
Variable type & \texttt{SSC\_INPUT}, \texttt{SSC\_OUTPUT}, \texttt{SSC\_INOUT} \\
Data type & \texttt{SSC\_NUMBER}, \texttt{SSC\_STRING}, \texttt{SSC\_ARRAY}, \texttt{SSC\_MATRIX}, \texttt{SSC\_TABLE} \\
Name & Variable name (case insensitive) \\
Label & A description of the variable's purpose \\
Units & The units of the numerical value(s) \\
Meta & Additional information. Could specify encoding of values, see below. \\
Group & General category of variable, e.g. ``Weather'', ``System Input'' \\
Required & Specifies whether the variable must be assigned a value. See \S\ref{sec_def_const} \\
Constraints & Constraints on the values or number of values. See \S\ref{sec_def_const} \\
UI Hints & Suggestions on how to display this variable.  Currently unused. \\
\end{tabular}
\caption{Variable information provided by SSC}
\label{tab_varinfo}
\end{center}
\end{table}

Consequently, SSC provides functions in the API to return information about all of the variables defined by a module.  Each variable specifies the information shown in Table~\ref{tab_varinfo}.


To obtain information for a variable, a module is queried using the \texttt{ssc\_module\_var\_info()} function, which returns a \texttt{ssc\_info\_t} reference.  The \texttt{ssc\_module\_var\_info()} function is called repeatedly with an index variable that is incremented by the user to cycle through all of the variables defined by the module.  An example is shown below, assuming that the variable \texttt{module} has been successfully created for a particular simulation module (e.g., see \S\ref{sec_ex_pvwatts_module}).  Querying SSC for available modules is discussed in \S\ref{sec_modules_querying}.

\begin{verbatimtab}
int i=0;
ssc_info_t p_inf = NULL;
while ( p_inf = ssc_module_var_info( module, i++ ) )
{
	// var_type: SSC_INPUT, SSC_OUTPUT, SSC_INOUT
	int var_type = ssc_info_var_type( p_inf );

	// data_type: SSC_STRING, SSC_NUMBER, SSC_ARRAY, SSC_MATRIX, SSC_TABLE   
	int data_type = ssc_info_data_type( p_inf );
      
	const char *name = ssc_info_name( p_inf );
	const char *label = ssc_info_label( p_inf );
	const char *units = ssc_info_units( p_inf );
	const char *meta = ssc_info_meta( p_inf );
	const char *group = ssc_info_group( p_inf );
	const char *required = ssc_info_required( p_inf );
	const char *constraints = ssc_info_constrants( p_inf );

	// here, you can print all of this data to text file
	// or present it in another way to the user

	printf( "%s %s (%s) %s\n", name, label, units, meta );
}

\end{verbatimtab}

The interactive SSCdev tool provided with the SSC library automatically generates all of this documentation for all modules in an interactive GUI spreadsheet-style interface.  This utility will be discussed in more detail in \S\ref{sec_sscdev_vars}.

\subsection{Default Values and Constraints}
\label{sec_def_const}

Sometimes there are so many input variables for a module that SSC assigns reasonable default values for some of the inputs if they are not explicitly specified by the user.  In other cases, some inputs may only have relevance for advanced users, and so a standard default value is provided that is recommended for the majority of simulations.  If a default value is provided, it is specified in the \emph{required} field of the variable information table.

If the \emph{required} field contains \texttt{``*''}, this means that there is no default value and the user must specify one in all cases.  If the \emph{required} field begins with the character \texttt{``?''}, it means that the variable is optional, and that SSC will use the value assigned by the user if it is provided.  The manner in which an optional variable affects the calculation is specific to each module, and so cannot be expanded upon here.

A default value is provided by SSC if the \emph{required} field appears as \texttt{``?=<value>''}, where \texttt{<value>} may be a number, a text string, or comma-separated array, depending on the data type of the variable.  In effect, this means that the variable always be given a value before simulation, but the user need not specify it.  For example, the \texttt{pvwattsv1} module specifies \texttt{rotlim} (tracker rotation limit) variable's \emph{required} field as \texttt{``?=45.0''}, meaning that unless the user specifies a different value, a rotation limit of 45 degrees is used.

In addition to providing some default values, SSC performs some data input validation before running a simulation using the \emph{constraints} field.  This field may optionally define any number of flags recognized by SSC that may limit the valid range of a numeric input variable, or define the required length of an input array.  A selection of the flags used by SSC is listed in Table~\ref{tab_constraints}.  Note that these flags are defined internally by the modules, and are not editable by users.  Also, in the case that the \emph{constraints} field is empty, that does not necessarily imply that any values are acceptable - the module writer may have inadvertently omitted a constraint flag, and may instead manually check each variable when the module runs.

\begin{table}[ht]
\begin{center}
\begin{tabular}{ll}
Flag & Description\\
\hline
\texttt{MIN=<value>} & desc \\
\texttt{MAX=<value>} & desc \\
\texttt{BOOLEAN} & desc \\
\texttt{INTEGER} & desc \\
\texttt{POSITIVE} & desc \\
\texttt{LOCAL\_FILE} & desc \\
\end{tabular}
\caption{Some constraints recognized by SSC}
\label{tab_constraints}
\end{center}
\end{table}

\subsection{Manipulating Data Containers}

\subsection{Assigning and Retrieving Values}


\section{Simulation Modules}
\label{sec_modules}

\subsection{Available Modules}
\label{sec_modules_querying}

\section{Handling Warnings and Errors}

\section{Integrating with Other Software}

\section{Using the SSCdev Tool}

\subsection{Looking up Variables}
\label{sec_sscdev_vars}

\section{Language Interfaces}
\subsection{Native C/C++}
\subsection{MATLAB}
\subsection{Visual Basic for Applications (VBA)}
\subsection{Java via Native Interface}
\subsection{C\# and .NET}
\subsection{PHP}
\subsection{Python}
\subsection{Ruby-on-Rails}

\section{C API Reference}

%\input{ssc_functions.tex}

\end{document}