<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="generator" content="hevea 2.00">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding 0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
</style>
<title>SSC Reference Manual
</title>
</head>
<body >
<!--HEVEA command line is: c:\hevea\hevea -exec xxdate.exe ssc_guide.tex -->
<!--CUT STYLE article--><!--CUT DEF section 1 --><table class="title"><tr><td><h1 class="titlemain">SSC Reference Manual</h1><h3 class="titlerest">Aron P. Dobos</h3></td></tr>
</table><p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

</p><blockquote class="abstract"><span style="font-weight:bold">Abstract: </span>
The SSC (SAM Simulation Core) software library implements the underlying renewable energy system modeling calculation engine utilitized by the popular desktop System Advisor Model (SAM) tool. SSC provides a simple and programmer-friendly application programming interface (API) that allows developers to directly integrate SAM calculations into other tools. The API includes mechanisms to set input variable values, run simulations, and retrieve calculated outputs. The library is provided to users as pre-compiled binary dynamic libraries for Windows, Mac OSX, and Linux, with the bare minimum system library dependencies. While the native API language is ISO-standard C, language bindings for MATLAB, and Python are included. The API and model implementations are thread-safe and reentrant, allowing the software to be efficiently utilized in a parallel computing environment.<p>This document describes the software architecture of SSC, introduces the SSC Development Environment tool, explains how to set up simulations from code, query the library for variable information, and provides examples and &#X201C;case studies" in various programming languages to ease the adoption of SSC into other systems. </p><p><span style="font-weight:bold">Note.</span> The reader is assumed to have familiarity with the C programming language, as well as some level of proficiency using the System Advisor Model (SAM) tool.
</p></blockquote><!--TOC section id=sec1 Contents-->
<h2 id="sec1" class="section">Contents</h2><!--SEC END -->
<!--TOC section id=sec2 Overview-->
<h2 id="sec2" class="section">1&#XA0;&#XA0;Overview</h2><!--SEC END --><p>
<a id="sec_overview"></a></p><p>The SSC software library provides a standard interface through which complex engineering and economic models of renewable energy systems can be configured and invoked. The System Advisor Model (SAM) desktop application is essentially a user-friendly front-end for SSC, and uses SSC to perform all system performance and financial calculations. It is assumed that the reader is well versed in SAM, its suite of models, typical inputs and outputs, and general usage.</p>
<!--TOC subsection id=sec3 Framework Description-->
<h3 id="sec3" class="subsection">1.1&#XA0;&#XA0;Framework Description</h3><!--SEC END --><p>SSC is designed as a general simulation framework that is model agnostic. For example, there is no specific <span style="font-family:monospace">pvwatts(...)</span> function call in the API that accepts model parameters and returns a calculated result. Rather, a generic mechanism is provided for sending a model data, running the model, and retrieving results from it. </p><p>The standard way to invoke a model in SSC involves three steps:</p><ol class="enumerate" type=1><li class="li-enumerate">
A generic data container is populated by the user with named variables and their values. These variables are inputs to the model.
</li><li class="li-enumerate">A particular model (like <span style="font-family:monospace">pvwattsv1</span>) is selected to <em>process</em> the data container. The model may run successfully using the input variables defined by the user, or fail with error messages. If the model succeeds, it populates the data container with the calculated output variables.
</li><li class="li-enumerate">Calculated outputs are retrieved from the data container, or error messages are retrieved.
</li></ol><p>Essentially, this sequence is no different than calling a function in a programming language. Step&#XA0;1 can be thought of as passing parameters to the function, step&#XA0;2 as running the function, and step&#XA0;3 as getting the calculated result returned. In SSC, the &#X201C;function&#X201D; is called a <em>module</em>, and the data container is simply <em>data</em>. The <em>module</em> operates on the <em>data</em> and transforms it by calculating new variables and adding them to the dataset. In the API, these are represented by the <span style="font-family:monospace">ssc_module_t</span> and <span style="font-family:monospace">ssc_data_t</span> types, which will be covered in detail later.</p>
<!--TOC subsection id=sec4 Modeling Systems-->
<h3 id="sec4" class="subsection">1.2&#XA0;&#XA0;Modeling Systems</h3><!--SEC END --><p>
<a id="sec_modeling_systems"></a>
Different modules are available in SSC for each type of simulation possible in SAM. A sample of modules is shown in Table&#XA0;<a href="#tab_sample_modules">??</a>.</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >Module</td><td style="text-align:left;white-space:nowrap" >Description </td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">pvwattsv1</span></td><td style="text-align:left;white-space:nowrap" >Implements the NREL PVWatts model for PV performance</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">pvsamv1</span></td><td style="text-align:left;white-space:nowrap" >Implements the component-based PV models in SAM</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">wfreader</span></td><td style="text-align:left;white-space:nowrap" >Reads standard format weather data files (TM2, TM3, EPW, SMW)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">irradproc</span></td><td style="text-align:left;white-space:nowrap" >General purpose irradiance processor for calculating POA</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">windpower</span></td><td style="text-align:left;white-space:nowrap" >Implements the NREL wind turbine and simple wind farm model</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">cashloan</span></td><td style="text-align:left;white-space:nowrap" >Implements residential and commercial cashflow economic model</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">ippppa</span></td><td style="text-align:left;white-space:nowrap" >Commercial PPA and Independent Power Producer (IPP) financial models</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">annualoutput</span></td><td style="text-align:left;white-space:nowrap" >Calculates degraded out-years system output for the analysis period</td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">utilityrate</span></td><td style="text-align:left;white-space:nowrap" >Calculates the value of energy using complex utility rate structures</td></tr>
</table>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Table 1: Some commonly used SSC modules</td></tr>
</table></div>
<a id="tab_sample_modules"></a>
</div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>To perform a complete technoeconomic systems analysis, multiple compute modules can be called in succession. For example, when the PVWatts+Residential configuration is selected in SAM, several compute modules are called in to perform the calculation, as listed below.</p><ol class="enumerate" type=1><li class="li-enumerate">
<span style="font-family:monospace">pvwattsv1</span>: The system parameters are used to calculate the hourly PV system performance.
</li><li class="li-enumerate"><span style="font-family:monospace">annualoutput</span>: The availability and degradation factors are applied to the annual energy output for the duration of the specified analysis period.
</li><li class="li-enumerate"><span style="font-family:monospace">utilityrate</span>: The value of the generated energy is calculated given the specifics of the complex utility rate structure, and the first year&#X2019;s hourly energy value is reported, along with the annual total value of energy at each year of the analysis period.
</li><li class="li-enumerate"><span style="font-family:monospace">cashloan</span>: Given the amount of the energy produced each year and the dollar value of this energy, this module calculates the cost of energy, net present value, and other metrics of the system based on specified system cost, incentives, operation and maintainance costs, taxes, and loan parameters.
</li></ol><p>In some cases, the output variables of one module have the right units and number of data values to feed directly into the next module in a sequence, but this is not enforced. For example, the <span style="font-family:monospace">pvwattsv1</span> module has an output variable <span style="font-family:monospace">ac</span> which is the hourly energy in kWh produced by the system. However, the <span style="font-family:monospace">annualoutput</span> module requires an input with the name <span style="font-family:monospace">energy_net_hourly</span>. It is up to the user to ensure that variables are translated appropriately between the outputs of one module and the inputs of another, including any units conversions that may be necessary. Luckily, SSC provides exhaustive documentation of all of the input variables required by a module and all of the outputs that will be calculated. Working with input and output variables will be the topic of a subsequent chapter.</p>
<!--TOC section id=sec5 A Basic Example: PVWatts-->
<h2 id="sec5" class="section">2&#XA0;&#XA0;A Basic Example: PVWatts</h2><!--SEC END --><p>In this section, we will write a simple command-line C program to calculate the monthly energy production of a 1 kW PV system at a particular location. The complete source code for this example program is included with the SSC SDK in the file <span style="font-family:monospace">example1_pvwatts.c</span>.</p>
<!--TOC subsection id=sec6 Program Skeleton-->
<h3 id="sec6" class="subsection">2.1&#XA0;&#XA0;Program Skeleton</h3><!--SEC END --><p>The SSC API is defined a C header called <span style="font-family:monospace">sscapi.h</span>, and this file must be included in your program before any SSC functions can be called. We will assume that the weather file is specified as a command line argument, and is one of the types that the <span style="font-family:monospace">pvwattsv1</span> can read (TM2, TM3, EPW, SMW). The skeleton of our program might look like the listing below.</p><pre>
#include &lt;stdio.h&gt;
#include "sscapi.h"

int main(int argc, char *argv[])
{
    if ( argc &lt; 2 )
    {
        printf("usage: pvwatts.exe &lt;weather-file&gt;\n");
        return -1;
    }
 
    // run PVWatts simulation for the specified weather file
    
    return 0;
}
</pre>
<!--TOC subsection id=sec7 Setting up data inputs-->
<h3 id="sec7" class="subsection">2.2&#XA0;&#XA0;Setting up data inputs</h3><!--SEC END --><p>Now we will fill in the comment in the middle of the code step-by-step. Referring to the three step process outlined in Section&#XA0;<a href="#sec_overview">??</a>, the first task is to create a data container. This is done with the <span style="font-family:monospace">ssc_data_create()</span> function call, which returns an <span style="font-family:monospace">ssc_data_t</span> type. If for some reason the function call fails due to the system having run out of memory, <span style="font-family:monospace">NULL</span> will be returned. It is important to check the result to make sure the data container was created successfully.</p><pre>
    ssc_data_t data = ssc_data_create();
    if ( data == NULL )
    {
        printf("error: out of memory.\n");
        return -1;
    }
</pre><p>Next, we assign the input variables required by the <span style="font-family:monospace">pvwattsv1</span> module. In &#XA7;<a href="#chap_variables">??</a>, we will show how to obtain information about the data types, names, labels, and units of variables. For now, it suffices to say that SSC supports data as numbers, text strings, arrays, matrices, and tables.</p><pre>
    ssc_data_set_string( data, "file_name", argv[1] ); // set the weather file name
    ssc_data_set_number( data, "system_size", 1.0f );  // system size of 1 kW DC
    ssc_data_set_number( data, "derate", 0.77f );      // system derate
    ssc_data_set_number( data, "track_mode", 0 );      // fixed tilt system
    ssc_data_set_number( data, "tilt", 20 );           // 20 degree tilt
    ssc_data_set_number( data, "azimuth", 180 );       // south facing (180 degrees)
</pre><p>At this point, we have a data container with six variables that are the input parameters to the module that we wish to run. </p>
<!--TOC subsection id=sec8 Simulating and retrieving outputs-->
<h3 id="sec8" class="subsection">2.3&#XA0;&#XA0;Simulating and retrieving outputs</h3><!--SEC END --><p>
<a id="sec_ex_pvwatts_module"></a></p><p>Next, an instance of the module itself must be created, per below. The name of the desired module must be passed to the <span style="font-family:monospace">ssc_module_create()</span> function. If the specified module name is not recognized, or the system is out of memory, the function may return <span style="font-family:monospace">NULL</span>.</p><pre>
    ssc_module_t module = ssc_module_create( "pvwattsv1" );
    if ( NULL == module )
    {
        printf("error: could not create 'pvwattsv1' module.\n");
        ssc_data_free( data );
        return -1;
    }
</pre><p>Next, the simulation must be run. If all the required input variables have been defined in the data container and have appropriate data types and values, the simulation should finish successfully. Otherwise, an error will be flagged. </p><pre>
    if ( ssc_module_exec( module, data ) == 0 )
    {
        printf("error during simulation.\n");
        ssc_module_free( module );
        ssc_data_free( data );
        return -1;
    }
</pre><p>By default, the <span style="font-family:monospace">ssc_module_exec()</span> function prints any log or error messages to standard output on the console. There is a more complex way to run a simulation that can reroute messages somewhere else, for example if a program wanted to pop up a message box or collect all messages and return them to the sure. This will be discussed in later sections.</p><p>Assuming that the simulation succeeded, it is now time to extract the calculated results. Modules may calculate hundreds of outputs, but for this example, we simply are interested in the total AC energy produced by the 1 kW PV system. As it turns out, <span style="font-family:monospace">pvwattsv1</span> only provides the hourly data, so it is up to us to sum up the hourly values. The code snippet below shows how to query the data object for the <span style="font-family:monospace">ac</span> variable and aggregate it.</p><pre>
    double ac_total = 0;
    int len = 0;
    ssc_number_t *ac = ssc_data_get_array( data, "ac", &amp;len );
    if ( ac != NULL )
    {
        int i;
        for ( i=0; i&lt;len; i++ )
            ac_total += ac[i];
        printf("ac: %lg kWh\n", ac_total*0.001 );
    }
    else
    {
        printf("variable 'ac' not found.\n");
    }
</pre>
<!--TOC subsection id=sec9 Cleaning up-->
<h3 id="sec9" class="subsection">2.4&#XA0;&#XA0;Cleaning up</h3><!--SEC END --><p>We&#X2019;re now finished simulating the PV system and retrieving the results. To avoid filling up the computer&#X2019;s memory with unneeded data objects, it is important to free the memory when it is no longer needed. To this end, the <span style="font-family:monospace">ssc_module_free()</span> and <span style="font-family:monospace">ssc_data_free()</span> functions are provided. Note that after calling one of these functions, the <span style="font-family:monospace">module</span> and <span style="font-family:monospace">data</span> variables are invalidated and cannot be used unless reassigned to another or a new data object or module.</p><pre>	
        ssc_module_free( module );
        ssc_data_free( data );
</pre>
<!--TOC subsection id=sec10 Compiling and running-->
<h3 id="sec10" class="subsection">2.5&#XA0;&#XA0;Compiling and running</h3><!--SEC END --><p>Using the MinGW compiler toolchain on Windows, it is very straightforward to compile and run this example. Simply issue the command below at the Windows command prompt (<span style="font-family:monospace">cmd.exe</span> from Start/Run), assuming that the <span style="font-family:monospace">sscapi.h</span> header file and 32-bit <span style="font-family:monospace">ssc.dll</span> dynamic library is in the same folder as the source file. The complete source code for this example is included in the SSC SDK. This example was tested with MinGW gcc version 4.6.2.</p><pre class="verbatim">c:\&gt; gcc example1_pvwatts.c ssc.dll -o pvwatts.exe
</pre><p>To run the program, specify a weather file on the command-line. Here, we use TMY2 data for Daggett, CA, which is included in the SDK as <em>daggett.tm2</em>.</p><pre class="verbatim">c:\&gt; pvwatts.exe daggett.tm2
ac: 1468.54 kWh
</pre><p>If all goes well, the total annual AC kWh for the system is printed on the console.</p>
<!--TOC subsection id=sec11 Some additional comments-->
<h3 id="sec11" class="subsection">2.6&#XA0;&#XA0;Some additional comments</h3><!--SEC END --><p>The <span style="font-family:monospace">ssc_data_t</span> and <span style="font-family:monospace">ssc_module_t</span> data types are opaque references to internally defined data structures. The only proper way to interact with variables of these types is using the defined SSC function calls. As listed in the <span style="font-family:monospace">sscapi.h</span> header file, both are typedef&#X2019;d as <span style="font-family:monospace">void*</span>.</p>
<!--TOC section id=sec12 Data Variables-->
<h2 id="sec12" class="section">3&#XA0;&#XA0;Data Variables</h2><!--SEC END --><p>
<a id="sec_variables"></a></p><p>Simulation model inputs and outputs are stored in a data container of type <span style="font-family:monospace">ssc_data_t</span>, which is simply a collection of named variables. Internally, the data structure is an unordered map (hash table), permitted very fast lookup of variables by name. Every input and output variable in SSC is designated a name, a <em>variable type</em>, and a <em>data type</em>, along with other meta data (labels, units, etc). </p><p>The variable name is mechanism by which data are identified by SSC, and the user is required to supply input variables with names that SSC has predefined. Names can contain letters, numbers, and underscores. Although names can be defined with upper and lower case letters, SSC does not distinguish between them internally: hence <span style="font-family:monospace">Beam_Irradiance</span> is the same variable as <span style="font-family:monospace">beam_irradiance</span>.</p>
<!--TOC subsection id=sec13 Variable Types-->
<h3 id="sec13" class="subsection">3.1&#XA0;&#XA0;Variable Types</h3><!--SEC END --><p>The <em>variable type</em> identifies each variable as an input, output, or in-out variable. In the SSC API, these values are defined by the constants reproduced below.</p><pre>
#define SSC_INPUT 1
#define SSC_OUTPUT 2
#define SSC_INOUT 3
</pre><p>Input variables are required to be set by the user before a module is called, while output variables are calculated by the module and assigned to the data container when the module has finished running. In-out variables are supplied by the user before the model runs, and the model transforms the value in some fashion.</p><p>Note that from the perspective of the data container, inputs and outputs are stored without distinction in an equivalent manner. Thus, it is impossible to tell simply from the contents of a data container whether a variable was an input or an output - it is just a pile of data. It is only the simulation modules that specify the variable type.</p>
<!--TOC subsection id=sec14 Data Types-->
<h3 id="sec14" class="subsection">3.2&#XA0;&#XA0;Data Types</h3><!--SEC END --><p>Every variable in SSC is assigned a particular data type, and each simulation module to specifies the data type of each variable required as input, as well as the data type of each output. SSC can work with numbers, text strings, one-dimensional arrays, two-dimensional matrices, and tables. The data type constants are listed below.</p><pre>
#define SSC_INVALID 0
#define SSC_STRING 1
#define SSC_NUMBER 2
#define SSC_ARRAY 3
#define SSC_MATRIX 4
#define SSC_TABLE 5
</pre><p>All numbers are stored using the <span style="font-family:monospace">ssc_number_t</span> data type. By default, this is a typedef of the 32-bit floating point C data type (<span style="font-family:monospace">float</span>). The purpose of using <span style="font-family:monospace">float</span> instead of the 64-bit <span style="font-family:monospace">double</span> is to save memory. While a simulation module may perform all of its calculations internally using 64-bit precision floating point, the inputs and results are transferred into and out of SSC using the smaller data type.</p><p>Arrays (1-D) and matrices (2-D) store numbers only - there is no provision for arrays or matrices of text strings, or arrays of tables. Arrays and matrices are optimized for efficient storage and transfer of large amounts of numerical data. For example, a photovoltaic system simulation at 1 second timesteps for a whole year would produce 525,600 data points, and potentially several such data vectors might be reported by a single simulation model. This fact underscores the reasoning to use the 32-bit floating point data type: just 20 vectors of 525,600 values each would require 42 megabytes of computer memory.</p><p>SSC does not provision separate storage for integers and floating point values - all numbers are stored internally as floating point. However, a module may specific a numeric input with the <em>integer</em> constraint which is checked automatically before the module is run. Constraints will be discussed later.</p><p>Text strings (<span style="font-family:monospace">SSC_STRING</span>) are stored as 8-bit characters. SSC does not support multi-byte or wide-character string representations, and all variable names and labels use only the 7-bit ASCII Latin alphabet. Consequently, text is stored as null (&#X2019;\0&#X2019;) terminated <span style="font-family:monospace">char*</span> C strings. Weather file names are common input variables that use the <span style="font-family:monospace">SSC_STRING</span> data type.</p><p>The table (<span style="font-family:monospace">SSC_TABLE</span>) data type is the only hierarchical data type in SSC. Essentially, it allows a simulation module to receive or return outputs in a structured format with named fields. A table is nothing more than a named variable that is itself a data container, which can store any number of named variables of any SSC data type. Currently, most SSC modules do not make heavy use of tables, but they are fully implemented and supported for future complex modules that may be added.</p>
<!--TOC subsection id=sec15 Variable Documentation-->
<h3 id="sec15" class="subsection">3.3&#XA0;&#XA0;Variable Documentation</h3><!--SEC END --><p>As stated before, each module defines all of the input variables it requires and output variables it produces. Since SSC is a model simulation framework that contains within it numerous calculation modules that each may have hundreds of variables, it is impractical to separate to the documentation of variables from their definitions. Otherwise, the documentation would tend to be consistently out of date as modules are updated and new ones are added.
</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >Field</td><td style="text-align:left;white-space:nowrap" >Description</td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >Variable type</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">SSC_INPUT</span>, <span style="font-family:monospace">SSC_OUTPUT</span>, <span style="font-family:monospace">SSC_INOUT</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >Data type</td><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">SSC_NUMBER</span>, <span style="font-family:monospace">SSC_STRING</span>, <span style="font-family:monospace">SSC_ARRAY</span>, <span style="font-family:monospace">SSC_MATRIX</span>, <span style="font-family:monospace">SSC_TABLE</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >Name</td><td style="text-align:left;white-space:nowrap" >Variable name (case insensitive) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >Label</td><td style="text-align:left;white-space:nowrap" >A description of the variable&#X2019;s purpose </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >Units</td><td style="text-align:left;white-space:nowrap" >The units of the numerical value(s) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >Meta</td><td style="text-align:left;white-space:nowrap" >Additional information. Could specify encoding of values, see below. </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >Group</td><td style="text-align:left;white-space:nowrap" >General category of variable, e.g. &#X201C;Weather&#X201D;, &#X201C;System Input&#X201D; </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >Required</td><td style="text-align:left;white-space:nowrap" >Specifies whether the variable must be assigned a value. See &#XA7;<a href="#sec_def_const">??</a> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >Constraints</td><td style="text-align:left;white-space:nowrap" >Constraints on the values or number of values. See &#XA7;<a href="#sec_def_const">??</a> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >UI Hints</td><td style="text-align:left;white-space:nowrap" >Suggestions on how to display this variable. Currently unused. </td></tr>
</table>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Table 2: Variable information provided by SSC</td></tr>
</table></div>
<a id="tab_varinfo"></a>
</div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Consequently, SSC provides functions in the API to return information about all of the variables defined by a module. Each variable specifies the information shown in Table&#XA0;<a href="#tab_varinfo">??</a>.</p><p>To obtain information for a variable, a module is queried using the <span style="font-family:monospace">ssc_module_var_info()</span> function, which returns a <span style="font-family:monospace">ssc_info_t</span> reference. The <span style="font-family:monospace">ssc_module_var_info()</span> function is called repeatedly with an index variable that is incremented by the user to cycle through all of the variables defined by the module. An example is shown below, assuming that the variable <span style="font-family:monospace">module</span> has been successfully created for a particular simulation module (e.g., see &#XA7;<a href="#sec_ex_pvwatts_module">??</a>). Querying SSC for available modules is discussed in &#XA7;<a href="#sec_modules_querying">??</a>.</p><pre>
int i=0;
ssc_info_t p_inf = NULL;
while ( p_inf = ssc_module_var_info( module, i++ ) )
{
    // var_type: SSC_INPUT, SSC_OUTPUT, SSC_INOUT
    int var_type = ssc_info_var_type( p_inf );

    // data_type: SSC_STRING, SSC_NUMBER, SSC_ARRAY, SSC_MATRIX, SSC_TABLE   
    int data_type = ssc_info_data_type( p_inf );
      
    const char *name = ssc_info_name( p_inf );
    const char *label = ssc_info_label( p_inf );
    const char *units = ssc_info_units( p_inf );
    const char *meta = ssc_info_meta( p_inf );
    const char *group = ssc_info_group( p_inf );
    const char *required = ssc_info_required( p_inf );
    const char *constraints = ssc_info_constrants( p_inf );

    // here, you can print all of this data to text file
    // or present it in another way to the user

    printf( "%s %s (%s) %s\n", name, label, units, meta );
}

</pre><p>The interactive SSCdev tool provided with the SSC library automatically generates all of this documentation for all modules in an interactive GUI spreadsheet-style interface. This utility will be discussed in more detail in &#XA7;<a href="#sec_sscdev_vars">??</a>.</p>
<!--TOC subsection id=sec16 Default Values and Constraints-->
<h3 id="sec16" class="subsection">3.4&#XA0;&#XA0;Default Values and Constraints</h3><!--SEC END --><p>
<a id="sec_def_const"></a></p><p>Sometimes there are so many input variables for a module that SSC assigns reasonable default values for some of the inputs if they are not explicitly specified by the user. In other cases, some inputs may only have relevance for advanced users, and so a standard default value is provided that is recommended for the majority of simulations. If a default value is provided, it is specified in the <em>required</em> field of the variable information table.</p><p>If the <em>required</em> field contains <span style="font-family:monospace">&#X2018;&#X2018;*&#X2019;&#X2019;</span>, this means that there is no default value and the user must specify one in all cases. If the <em>required</em> field begins with the character <span style="font-family:monospace">&#X2018;&#X2018;?&#X2019;&#X2019;</span>, it means that the variable is optional, and that SSC will use the value assigned by the user if it is provided. The manner in which an optional variable affects the calculation is specific to each module, and so cannot be expanded upon here.</p><p>A default value is provided by SSC if the <em>required</em> field appears as <span style="font-family:monospace">&#X2018;&#X2018;?=&lt;value&gt;&#X2019;&#X2019;</span>, where <span style="font-family:monospace">&lt;value&gt;</span> may be a number, a text string, or comma-separated array, depending on the data type of the variable. In effect, this means that the variable always be given a value before simulation, but the user need not specify it. For example, the <span style="font-family:monospace">pvwattsv1</span> module specifies <span style="font-family:monospace">rotlim</span> (tracker rotation limit) variable&#X2019;s <em>required</em> field as <span style="font-family:monospace">&#X2018;&#X2018;?=45.0&#X2019;&#X2019;</span>, meaning that unless the user specifies a different value, a rotation limit of 45 degrees is used.</p><p>In addition to providing some default values, SSC performs some data input validation before running a simulation using the <em>constraints</em> field. This field may optionally define any number of flags recognized by SSC that may limit the valid range of a numeric input variable, or define the required length of an input array. A selection of the flags used by SSC is listed in Table&#XA0;<a href="#tab_constraints">??</a>. Note that these flags are defined internally by the modules, and are not editable by users. Also, in the case that the <em>constraints</em> field is empty, that does not necessarily imply that any values are acceptable - the module writer may have inadvertently omitted a constraint flag, and may instead manually check each variable when the module runs.</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >Flag</td><td style="text-align:left;white-space:nowrap" >Description</td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">MIN=&lt;value&gt;</span></td><td style="text-align:left;white-space:nowrap" >Specifies the minimum permissible value for a number </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">MAX=&lt;value&gt;</span></td><td style="text-align:left;white-space:nowrap" >Specifies the maximum permissible value for a number </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">BOOLEAN</span></td><td style="text-align:left;white-space:nowrap" >Requires the number to be equal to 0 (false) or 1 (true) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">INTEGER</span></td><td style="text-align:left;white-space:nowrap" >Requires the number to be an integer value </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">POSITIVE</span></td><td style="text-align:left;white-space:nowrap" >Requires the number to have a positive, non-zero value </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-family:monospace">LOCAL_FILE</span></td><td style="text-align:left;white-space:nowrap" >Requires the text string to be a local file on disk that is readable and exists </td></tr>
</table>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Table 3: Some constraints recognized by SSC</td></tr>
</table></div>
<a id="tab_constraints"></a>
</div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Constraints can be combined to further restrict the value of a number. For example, in <span style="font-family:monospace">pvwattsv1</span>, the <span style="font-family:monospace">track_mode</span> variable&#X2019;s constraints field is <span style="font-family:monospace">&#X2018;&#X2018;MIN=0,MAX=3,INTEGER&#X2019;&#X2019;</span>. This specification limits the possible values of the variable to 0, 1, 2, or 3, which are the numeric values associated with a fixed, 1-axis, 2-axis, or azimuth-axis tracking PV system.</p>
<!--TOC subsection id=sec17 Manipulating Data Containers-->
<h3 id="sec17" class="subsection">3.5&#XA0;&#XA0;Manipulating Data Containers</h3><!--SEC END --><p>
<a id="sec_data_manip"></a></p><p>As was shown in the initial PVWatts example, a data container is created and freed using the <span style="font-family:monospace">ssc_data_first()</span> and <span style="font-family:monospace">ssc_data_next()</span> functions. Here, some additional functions for working with data containers are explored.</p><p>The <span style="font-family:monospace">ssc_data_unassign()</span> function removes a variable from the container, releasing any memory associated with it. To erase all of the variables in a container and leave it empty (essentially resetting it), use the <span style="font-family:monospace">ssc_data_clear()</span> function. For example:</p><pre>
ssc_data_unassign( data, "tilt" ); // remove the 'tilt' variable

ssc_data_clear( data ); // reset the container by erasing all the variables
</pre><p>To find out the names of all variables in a container, functions <span style="font-family:monospace">ssc_data_first()</span> and <span style="font-family:monospace">ssc_data_next()</span> are used. These functions return the name of a variable, or <span style="font-family:monospace">NULL</span> if there are no more variables in the container. The <span style="font-family:monospace">ssc_data_query()</span> function returns the data type of the specified variable, which is useful for subsequently retrieving its value. The example below prints out the text of all the string variables in a data container:</p><pre>
const char *name = ssc_data_first( data );
while( name != 0 )
{
    // do something, like query the data type
    int type = ssc_data_query( data, name );

    if ( type == SSC_STRING )
    {
        const char *text = ssc_data_get_string( data, name );
        printf("string variable %s: %s\n", name, text );
    }

    name = ssc_data_next( data );
}
</pre><p>See the API reference in &#XA7;<a href="#sec_api_ref">??</a> for detailed documentation of each function&#X2019;s parameters and return values.</p>
<!--TOC subsection id=sec18 Assigning and Retrieving Values-->
<h3 id="sec18" class="subsection">3.6&#XA0;&#XA0;Assigning and Retrieving Values</h3><!--SEC END --><p>This section discusses the particulars of assigning and retrieving variable values. Note that assigning a variable that already exists in the container causes the old value to be erased.</p>
<!--TOC subsubsection id=sec19 Numbers-->
<h4 id="sec19" class="subsubsection">3.6.1&#XA0;&#XA0;Numbers</h4><!--SEC END --><p>Numbers are transferred and stored using the <span style="font-family:monospace">ssc_number_t</span> data type. To assign a value:</p><pre class="verbatim">ssc_data_set_number( data, "track_mode", 2 ); // integer value
ssc_data_set_number( data, "tilt", 30.5f ); // floating point value

ssc_number_t azimuth = 182.3f;
ssc_data_set_number( data, "azimuth", azimuth ); // from a variable
</pre><p>To retrieve a numeric value, it must be declared first, since the retrieval function returns true or false. False is returned if the specified variable does not exist in the data container.</p><pre>
ssc_number_t value;
if( ssc_data_get_number( data, "tilt", &amp;value ) )
    printf( "tilt = %f\n", value );
else
    printf( "not found\n" );
</pre>
<!--TOC subsubsection id=sec20 Arrays-->
<h4 id="sec20" class="subsubsection">3.6.2&#XA0;&#XA0;Arrays</h4><!--SEC END --><p>Arrays are passed to SSC using standard C arrays (pointers), along with the length of the array. Examples:</p><pre>
ssc_number_t monthdays[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
ssc_data_set_array( data, "nday", monthdays, 12 );

// dynamically allocate an array of size len
ssc_number_t *xx = (ssc_number_t*) malloc( sizeof(ssc_number_t)*len );
for( i=0; i&lt;len; i++ ) xx[i] = i*i;

ssc_data_set_array( data, "isquared", xx, len );

free( xx ); // SSC does not take ownership, so free any arrays here.
</pre><div class="center"><div class="minipage"><span class="textboxed"><span style="font-weight:bold">Note: </span></span><span class="textboxed">When assigning an array, SSC makes an internal copy, and does not take ownership of the array passed in. Thus it is up to the user to deallocate any memory created in the client code as appropriate.</span></div></div><p>Array data is retrieved from SSC using the <span style="font-family:monospace">ssc_data_get_array()</span> function. The length of the retrieved array is returned in the length reference parameter. If the requested variable is not assigned, or is not an <span style="font-family:monospace">SSC_ARRAY</span>, <span style="font-family:monospace">NULL</span> is returned. Example:</p><pre>
int len = 0;
const ssc_number_t *array = ssc_data_get_array( data, "xx", &amp;len );

if( array != NULL &amp;&amp; len &gt; 0 )
{
    printf("len: %d, first item=%f\n", len, array[0] );
}
</pre><div class="center"><div class="minipage"><span class="textboxed"><span style="font-weight:bold">Note: </span></span><span class="textboxed">The </span><span class="textboxed"><span style="font-family:monospace">ssc_data_get_array()</span></span><span class="textboxed"> returns a reference to internally managed memory: do not deallocate or otherwise change the array returned by it. This is done to improve efficiency when working with large data vectors.</span></div></div>
<!--TOC subsubsection id=sec21 Matrices-->
<h4 id="sec21" class="subsubsection">3.6.3&#XA0;&#XA0;Matrices</h4><!--SEC END --><p>Matrices are two dimensional arrays of numbers. In SSC, matrices are stored as one contiguous array, in row-major order. Like arrays, they consist of <span style="font-family:monospace">ssc_number_t</span> data and are passed to SSC using standard C arrays, along with the number of rows and columns.</p><p>Row-major ordering means that the two dimensional array is flattened into a single dimensional vector. In a 4x3 matrix, the flattened vector will have 12 values in which indices [0..3] represent the first row, [4..7] the second row, and [8..11] the third row. Example:</p><pre>
ssc_number_t mat[12] = { 4,4,5,1,
                         6,7,2,5,
                         1,6,2,3 };

ssc_data_set_matrix( data, "mat1", mat, 4, 3 );
</pre><div class="center"><div class="minipage"><span class="textboxed"><span style="font-weight:bold">Note: </span></span><span class="textboxed">SSC creates an internal copy of the matrix passed to </span><span class="textboxed"><span style="font-family:monospace">ssc_data_set_matrix()</span></span><span class="textboxed">. If the matrix was allocated dyamically, it is up to the user written client code to deallocate it properly: SSC does not take ownership.</span></div></div><p>Matrices are returned in the same format. If the requested variable does not exist or is not a matrix, <span style="font-family:monospace">NULL</span> is returned. Example:</p><pre>
int nrows, ncols;
ssc_number_t *mat = ssc_data_get_matrix( data, "mat1", &amp;nrows, &amp;ncols );

if( mat != NULL &amp;&amp; nrows == 4 &amp;&amp; ncols == 3 )
{
    int r, c, index = 0;
    for( r=0; r&lt;nrows; r++ )
        for( c=0; c&lt;ncols; c++ )
            printf( "mat[%d,%d]=%f\n", r, c, mat[index++] );
}
</pre><div class="center"><div class="minipage"><span class="textboxed"><span style="font-weight:bold">Note: </span></span><span class="textboxed">The </span><span class="textboxed"><span style="font-family:monospace">ssc_data_get_matrix()</span></span><span class="textboxed"> returns a reference to internally managed memory: do not deallocate or otherwise change the array returned by it.</span></div></div>
<!--TOC subsubsection id=sec22 Strings-->
<h4 id="sec22" class="subsubsection">3.6.4&#XA0;&#XA0;Strings</h4><!--SEC END --><p>SSC supports null-terminated ASCII text strings as a data type. Setting a string value is straightforward. SSC creates an internal copy of the string data. Examples:
</p><pre>
ssc_data_set_string( data, "weather_file", "c:/Data/Weather/TX Abilene.tm2" );

const char *location = "Hawaii";
ssc_data_set_string( data, "location", location );
</pre><p>Retrieving strings is similarly straightforward:</p><pre>
const char *location = ssc_data_get_string( data, "location" );
if( location != NULL )
    printf("location = %s\n", location );
</pre><div class="center"><div class="minipage"><span class="textboxed"><span style="font-weight:bold">Note: </span></span><span class="textboxed">Do not free or modify the pointer returned by </span><span class="textboxed"><span style="font-family:monospace">ssc_data_get_string()</span></span><span class="textboxed">. A reference to an internally managed character byte array is returned.</span></div></div>
<!--TOC subsubsection id=sec23 Tables-->
<h4 id="sec23" class="subsubsection">3.6.5&#XA0;&#XA0;Tables</h4><!--SEC END --><p>Tables provide a way to communicate data to SSC in a hierarchical structure format. This data type is provisioned for future simulation modules, but current ones do not use this data type. Nonetheless, the SSCdev utility (&#XA7;<a href="#sec_sscdev">??</a>) fully supports tables. Before a table can be assigned, it must be created and filled with variables. A table is simply a normal data container. Example:</p><pre>
ssc_data_t table = ssc_data_create(); // create an empty table
ssc_data_set_string( table, "first", "peter" );
ssc_data_set_string( table, "last", "jones" );
ssc_data_set_number( table, "age", 24 );

ssc_data_set_table( data, "person", table ); // assign the table

ssc_data_free( table ); // free the table after it is assigned
</pre><p>Since a table is a just an <span style="font-family:monospace">ssc_data_t</span> object, it can store any SSC data type, including another table. This structure allows for nested tables, as potentially needed by a future complicated simulation module.</p><div class="center"><div class="minipage"><span class="textboxed"><span style="font-weight:bold">Note: </span></span><span class="textboxed">SSC creates an internal copy of the table and all of its variables. As such, the table should be deallocated after it is assigned, per the example above.</span></div></div><p>Retrieving a table is a straightforward operation:</p><pre>
ssc_data_t table = ssc_data_get_table( data, "person" );
if( table != NULL )
{
    printf( "person.first = %s\n", ssc_data_get_string( table, "first" ) );
    printf( "person.last = %s\n", ssc_data_get_string( table, "last" ) );
}
// do not free the 'table' variable: it is internal to SSC
</pre><div class="center"><div class="minipage"><span class="textboxed"><span style="font-weight:bold">Note: </span></span><span class="textboxed">The </span><span class="textboxed"><span style="font-family:monospace">ssc_data_get_table()</span></span><span class="textboxed"> function returns an internal reference to a data container. Do not deallocate or otherwise modify the returned reference.</span></div></div><p>Note that the <span style="font-family:monospace">ssc_data_first()</span> and <span style="font-family:monospace">ssc_data_next()</span> functions described in &#XA7;<a href="#sec_data_manip">??</a> can be used to determine all of the fields of a table.</p>
<!--TOC section id=sec24 Simulation Modules-->
<h2 id="sec24" class="section">4&#XA0;&#XA0;Simulation Modules</h2><!--SEC END --><p>
<a id="sec_modules"></a></p><p>The SSC framework exposes several different simulation modules that calculate outputs given inputs. Each module can run independently of all the others, provided that all the input variables that are required are provided by the user. The System Advisor Model (SAM) tool often runs several SSC modules in succession to simulate the whole system performance and economic evaluation. In between successive calls to different SSC modules, SAM may change the names or scale the output variables of one module to set it up with appropriate inputs for the next one, as explained in &#XA7;<a href="#sec_modeling_systems">??</a>.</p>
<!--TOC subsection id=sec25 Querying SSC for Available Modules-->
<h3 id="sec25" class="subsection">4.1&#XA0;&#XA0;Querying SSC for Available Modules</h3><!--SEC END --><p>
<a id="sec_modules_querying"></a></p><p>SSC provides a programming interface by which the library can be queried about all of the modules contained within it. The example below prints all of the available modules to the console along with their version numbers and descriptions:</p><pre>
ssc_entry_t entry;
int index = 0;
while( entry = ssc_module_entry( index++ ) )
{
    const char *module_name = ssc_entry_name( entry );
    const char *description = ssc_entry_desc( entry );
    int version = ssc_entry_version( entry );

    printf( "Module %s, version %d: %s\n", module_name, version, description );
}
</pre>
<!--TOC subsection id=sec26 Simple Method #1-->
<h3 id="sec26" class="subsection">4.2&#XA0;&#XA0;Simple Method #1</h3><!--SEC END --><p>A simulation module can be invoked in one of several ways. The simplest way to call a module is to use the <span style="font-family:monospace">ssc_module_exec_simple()</span> function. This method prints any warnings or errors to the console, and simply returns true or false. The PVWatts example from earlier could be written as:</p><pre>
ssc_data_t data = ssc_data_create();
ssc_data_set_string( data, "file_name", "TX Abilene.tm2" );
ssc_data_set_number( data, "system_size", 4 );
ssc_data_set_number( data, "derate", 0.77f );
ssc_data_set_number( data, "track_mode", 0 );
ssc_data_set_number( data, "tilt", 20 );
ssc_data_set_number( data, "azimuth", 180 );

if( ssc_module_exec_simple( "pvwattsv1", data ) )
{
    int i, len;
    ssc_number_t ac_sum = 0;
    ssc_number_t *ac = ssc_data_get_array( data, "ac", &amp;len );
    for( i=0;i&lt;len;i++ ) ac_sum += ac[i];
    printf( "success, ac: %f Wh\n", ac_sum );

}
else
    printf( "an error occured\n" );

ssc_data_free( data );
</pre><p>Note that there is no need to explicitly create an <span style="font-family:monospace">ssc_module_t</span> object using <span style="font-family:monospace">ssc_module_create()</span>; the function will return false if the module name specified could not be found or could not be created.</p><p>The <span style="font-family:monospace">ssc_module_exec_simple()</span> function is thread-safe, provided that the module called is itself thread-safe. It is intended that all SSC modules are implemented in a thread-safe manner.</p>
<!--TOC subsection id=sec27 Simple Method #2-->
<h3 id="sec27" class="subsection">4.3&#XA0;&#XA0;Simple Method #2</h3><!--SEC END --><p>
A similar function to run a module exists that returns to the caller the first error message encountered. This variation of <em>exec</em> function is not thread-safe, as indicated by its name. Example:</p><pre>
// ... set up a data container with inputs ...

const char *error = ssc_module_exec_simple_nothread( "pvwattsv1", data );
if( error == NULL )
    printf("success!\n");
else
    printf( "module failed with error: %s\n", error );
</pre><p>In this case, a <span style="font-family:monospace">NULL</span> return value indicates that no error occurred.</p>
<!--TOC subsection id=sec28 Running with Progress Updates, Warnings, and Errors-->
<h3 id="sec28" class="subsection">4.4&#XA0;&#XA0;Running with Progress Updates, Warnings, and Errors</h3><!--SEC END --><p>The last (most complex) way to run a module is to provide a special handler that can reroute errors and warning messages, as well as provide progress updates to the controlling software. To accomplish this, the client code must provide a <em>handler</em> (aka <em>callback</em>) function to SSC. The handler function must have the signature below.</p><pre>
ssc_bool_t (*handler)( ssc_module_t module, 
        ssc_handler_t handle, 
        int action, 
        float f0, 
        float f1, 
        const char *s0, 
        const char *s1, 
        void *user_data );
</pre><div class="center"><div class="minipage"><span class="textboxed"><span style="font-weight:bold">Note: </span></span><span class="textboxed">This documentation is specific to the C language API for SSC handler functions. Not all programming language interfaces included with SSC (e.g. MATLAB, Python, VBA) support the custom handler mechanism described here. However, log messages (notices, warnings, errors) can still be retrieved after a simulation is completed using the </span><span class="textboxed"><span style="font-family:monospace">ssc_module_log()</span></span><span class="textboxed"> function (see &#XA7;</span><a href="#sec_messages"><span class="textboxed">??</span></a><span class="textboxed">, although real-time progress updates cannot be issued.</span></div></div><p>Supposing that such a function named <span style="font-family:monospace">my_ssc_handler_function()</span> has been defined, used the <span style="font-family:monospace">ssc_module_exec_with_handler()</span> function to run the module. You may pass an a generic data pointer to the function also, so that within the context of the handler the messages or progress updates can be routed accordingly.</p><pre>
void *my_data = &lt;some user data to send to the callback, or NULL&gt;;

if ( ssc_module_exec_with_handler( module, data, my_ssc_handler_function, my_data ) )
    printf("success!\n");
else
    printf("fail!\n");
</pre><p>The code below represents the default handler built into SSC. Note that the handler function must return a boolean (0/1) value to indicate to SSC whether to continue simulating or not. This provides the option to abort the simulation if a user has clicked a cancel button in the meantime, or similar. The various parameters are used to convey SSC status information to the handler, and have different meanings (and data) depending on the <span style="font-family:monospace">action_type</span> parameter.</p><pre>
static ssc_bool_t default_internal_handler( ssc_module_t p_mod, ssc_handler_t p_handler,
    int action_type, float f0, float f1, 
    const char *s0, const char *s1,
    void *user_data )
{
    if (action_type == SSC_LOG)
    {
        // print log messages to console
        std::cout &lt;&lt; "Log ";
        switch( (int)f0 ) // determines type
        {
        case SSC_NOTICE: 
            std::cout &lt;&lt; "Notice: " &lt;&lt; s0 &lt;&lt; " time " &lt;&lt; f1 &lt;&lt; std::endl; 
            break;
        case SSC_WARNING: 
            std::cout &lt;&lt; "Warning: " &lt;&lt; s0 &lt;&lt; " time " &lt;&lt; f1 &lt;&lt; std::endl; 
            break;
        case SSC_ERROR: 
            std::cout &lt;&lt; "Error: " &lt;&lt; s0 &lt;&lt; " time " &lt;&lt; f1 &lt;&lt; std::endl; 
            break;
        default: 
            std::cout &lt;&lt; "Unknown: " &lt;&lt; f0 &lt;&lt; " time " &lt;&lt; f1 &lt;&lt; std::endl; 
            break;
        }
        return 1;
    }
    else if (action_type == SSC_UPDATE)
    {
        // print status update to console
        std::cout &lt;&lt; "Progress " &lt;&lt; f0 &lt;&lt; "%:" &lt;&lt; s1 &lt;&lt; " time " &lt;&lt; f1 &lt;&lt; std::endl;
        return 1; // return 0 to abort simulation as needed.
    }
    else
        return 0;
}
</pre><p>As noted in previous sections, the default handler simply prints warnings, errors, and simulation progress updates to the standard output stream on the console. To implement a custom handler, it is recommended to copy the structure of the handler above, but to replace the output to the console with specialized handling for the messages and progress. For example, in a graphical user interface program, the <span style="font-family:monospace">user_data</span> pointer could be used to pass in a pointer to a dialog class containing a progress bar and a text box. The messages could be sent to the text box, and the progress bar updated appropriately. The custom SSC handler function implemented in the graphical SSCdev tool (based on the excellent wxWidgets GUI library) is reproduced below, showing how messages and progess can be reported to the user.</p><pre>
static ssc_bool_t my_handler( ssc_module_t p_mod, ssc_handler_t p_handler, int action, 
    float f0, float f1, const char *s0, const char *s1, void *user_data )
{
    wxProgressDialog *dlg = (wxProgressDialog*) user_data;
    if (action == SSC_LOG)
    {
        wxString msg;

        switch( (int)f0 )
        {
        case SSC_NOTICE: msg &lt;&lt; "Notice: " &lt;&lt; s0 &lt;&lt; " time " &lt;&lt; f1; break;
        case SSC_WARNING: msg &lt;&lt; "Warning: " &lt;&lt; s0 &lt;&lt; " time " &lt;&lt; f1; break;
        case SSC_ERROR: msg &lt;&lt; "Error: " &lt;&lt; s0 &lt;&lt; " time " &lt;&lt; f1; break;
        default: msg &lt;&lt; "Unknown: " &lt;&lt; f0 &lt;&lt; " time " &lt;&lt; f1; break;
        }

        // post the SSC message on the application-wide log window 
        app_frame-&gt;Log(msg);

        return 1;
    }
    else if (action == SSC_UPDATE)
    {
        // update progress dialog with percentage complete
        dlg-&gt;Update( (int) f0, s0 );
        wxGetApp().Yield(true);

        return 1; // return 0 to abort simulation as needed.
    }
    else
        return 0;
}
</pre><p>A third action type called <span style="font-family:monospace">SSC_EXECUTE</span> can be found in the SSC header file. This is an advanced capability that is not described in this user guide, and is intended to be removed in the future from the SSC API.</p>
<!--TOC subsection id=sec29 Retrieving Messages-->
<h3 id="sec29" class="subsection">4.5&#XA0;&#XA0;Retrieving Messages</h3><!--SEC END --><p>
<a id="sec_messages"></a></p><p>During simulation, a module may generate any number of (hopefully) informative messages about warnings or errors encountered. The custom handler approach allows these messages to be reported to the user as the simulation progresses, but they are also stored in the module for retrieval later. The <span style="font-family:monospace">ssc_module_log()</span> function allows the client code to retrieve all the messages, regardless of which execute function was used to run the module. Example:</p><pre>
const char *text;
int type;
float time;
int index = 0;
while( (text = ssc_module_log( module, index++, &amp;type, &amp;time )) )
{
    switch( type ) // determines type
    {
    case SSC_NOTICE: 
        std::cout &lt;&lt; "Notice: " &lt;&lt; text &lt;&lt; " time " &lt;&lt; time &lt;&lt; std::endl; 
        break;
    case SSC_WARNING: 
        std::cout &lt;&lt; "Warning: " &lt;&lt; text &lt;&lt; " time " &lt;&lt; time &lt;&lt; std::endl; 
        break;
    case SSC_ERROR: 
        std::cout &lt;&lt; "Error: " &lt;&lt; text &lt;&lt; " time " &lt;&lt; time &lt;&lt; std::endl; 
        break;
    default: 
        std::cout &lt;&lt; "Unknown: " &lt;&lt; text &lt;&lt; " time " &lt;&lt; time &lt;&lt; std::endl; 
        break;
    }
}
</pre><p>In essence, the <span style="font-family:monospace">ssc_module_log()</span> is called repeatedly with an increasing index number until the function returns <span style="font-family:monospace">NULL</span>, indicating that there are no more messages. Along with the text of the message, information about the type (notice, warning, error) and the time that it was issued by the module are reported.</p><div class="center"><div class="minipage"><span class="textboxed"><span style="font-weight:bold">Note: </span></span><span class="textboxed">Do not free the C string returned by </span><span class="textboxed"><span style="font-family:monospace">ssc_module_log()</span></span><span class="textboxed">. It is a reference to internally managed memory.</span></div></div>
<!--TOC section id=sec30 Version Information-->
<h2 id="sec30" class="section">5&#XA0;&#XA0;Version Information</h2><!--SEC END --><p>Functions are included in SSC to return version information and details about the particular build. For example:</p><pre>
int version = ssc_version();
const char *build = ssc_build_info();

printf( "ssc version %d: %s\n", version, build );
</pre><p>On Windows, this code may print:</p><pre>
    ssc version 22: Windows 32 bit Visual C++ Nov 13 2012 18:44:14
</pre><p>On Linux, a newer version of SSC may report something like:
</p><pre>
    ssc version 24: Unix 64 bit GNU/C++ Dec  5 2012 11:42:51
</pre>
<!--TOC section id=sec31 Using the SSCdev Tool-->
<h2 id="sec31" class="section">6&#XA0;&#XA0;Using the SSCdev Tool</h2><!--SEC END --><p>
<a id="sec_sscdev"></a></p>
<!--TOC subsection id=sec32 Looking up Variables-->
<h3 id="sec32" class="subsection">6.1&#XA0;&#XA0;Looking up Variables</h3><!--SEC END --><p>
<a id="sec_sscdev_vars"></a></p>
<!--TOC section id=sec33 Language Interfaces-->
<h2 id="sec33" class="section">7&#XA0;&#XA0;Language Interfaces</h2><!--SEC END -->
<!--TOC subsection id=sec34 Native C/C++-->
<h3 id="sec34" class="subsection">7.1&#XA0;&#XA0;Native C/C++</h3><!--SEC END -->
<!--TOC subsection id=sec35 MATLAB-->
<h3 id="sec35" class="subsection">7.2&#XA0;&#XA0;MATLAB</h3><!--SEC END -->
<!--TOC subsection id=sec36 Visual Basic for Applications (VBA)-->
<h3 id="sec36" class="subsection">7.3&#XA0;&#XA0;Visual Basic for Applications (VBA)</h3><!--SEC END -->
<!--TOC subsection id=sec37 Java via Native Interface-->
<h3 id="sec37" class="subsection">7.4&#XA0;&#XA0;Java via Native Interface</h3><!--SEC END -->
<!--TOC subsection id=sec38 C# and .NET-->
<h3 id="sec38" class="subsection">7.5&#XA0;&#XA0;C# and .NET</h3><!--SEC END -->
<!--TOC subsection id=sec39 PHP-->
<h3 id="sec39" class="subsection">7.6&#XA0;&#XA0;PHP</h3><!--SEC END -->
<!--TOC subsection id=sec40 Python-->
<h3 id="sec40" class="subsection">7.7&#XA0;&#XA0;Python</h3><!--SEC END -->
<!--TOC subsection id=sec41 Ruby-on-Rails-->
<h3 id="sec41" class="subsection">7.8&#XA0;&#XA0;Ruby-on-Rails</h3><!--SEC END -->
<!--TOC section id=sec42 C API Reference-->
<h2 id="sec42" class="section">8&#XA0;&#XA0;C API Reference</h2><!--SEC END --><p>
<a id="sec_api_ref"></a>
<a id="sscapi_8h"></p>
<!--TOC subsection id=sec43 F:/SAM SSC/ssc/ssc/sscapi.h File Reference-->
<h3 id="sec43" class="subsection">8.1&#XA0;&#XA0;F:/SAM SSC/ssc/ssc/sscapi.h File Reference</h3><!--SEC END --><p>
F:/SAM SSC/ssc/ssc/sscapi.h@F:/SAM SSC/ssc/ssc/sscapi.h
</a></p><p>The SAM Simulation Core (SSC) is a general purpose simulation input/output framework that is cross-platform (Windows/MacOSX/Unix) and compatible with both 32-bit and 64-bit operating systems. </p><!--TOC subsubsection id=sec44 Typedefs-->
<h4 id="sec44" class="subsubsection">Typedefs</h4><!--SEC END --><p>

typedef void &#X2217; <a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a>
typedef float <a href="#sscapi_8h_aed2c6c08a4d87fc653895a27065b5c8d">ssc_number_t</a>
typedef int <a href="#sscapi_8h_a8416be1f3d7e7d4457bf37e657277575">ssc_bool_t</a>
typedef void &#X2217; <a href="#sscapi_8h_a0f778c7e3611dfc2ba01e5bd89979f80">ssc_entry_t</a>
typedef void &#X2217; <a href="#sscapi_8h_adf8d62c898e485fc7440d3ed2fb0d87c">ssc_module_t</a>
typedef void &#X2217; <a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a>
typedef void &#X2217; <a href="#sscapi_8h_a64a6b436524349ccf0a77b56b2cf4e9d">ssc_handler_t</a>

</p><!--TOC subsubsection id=sec45 Functions-->
<h4 id="sec45" class="subsubsection">Functions</h4><!--SEC END --><p>

SSCEXPORT int <a href="#sscapi_8h_a4460dd3f2316afa8a766769445e9fcd6">ssc_version</a> ()
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_ab34ddddf0832ff80d36c08af415fcf61">ssc_build_info</a> ()
SSCEXPORT <a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> <a href="#sscapi_8h_ac9f368730a0da3c79169cd6d3eef8f0b">ssc_data_create</a> ()
SSCEXPORT void <a href="#sscapi_8h_acc9123254cfd9b1483a34a840ba66f3f">ssc_data_free</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data)
SSCEXPORT void <a href="#sscapi_8h_adc28c6035c08ce6f88d5e228b3d3cd25">ssc_data_clear</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data)
SSCEXPORT void <a href="#sscapi_8h_a5044cd17abb621f4549c6fd0aab77277">ssc_data_unassign</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name)
SSCEXPORT int <a href="#sscapi_8h_ab6598d213b423fe7c3b85071119f4cb0">ssc_data_query</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_ad499cfe8696e1f704d968b50d3ab36b1">ssc_data_first</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_a56b8a556bfe81c4f65fa2f3c41b5db31">ssc_data_next</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data)
SSCEXPORT void <a href="#sscapi_8h_aa660663a8343fb2ddb7f7aa1d6a93205">ssc_data_set_string</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name, const char &#X2217;value)
SSCEXPORT void <a href="#sscapi_8h_a42e160996afdef0ab4b3c085c253e364">ssc_data_set_number</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name, <a href="#sscapi_8h_aed2c6c08a4d87fc653895a27065b5c8d">ssc_number_t</a> value)
SSCEXPORT void <a href="#sscapi_8h_a2a65f966686e481fc4f63803a968f3d4">ssc_data_set_array</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name, <a href="#sscapi_8h_aed2c6c08a4d87fc653895a27065b5c8d">ssc_number_t</a> &#X2217;pvalues, int length)
SSCEXPORT void <a href="#sscapi_8h_ae823313deeeb06e37ddf6dfaab17190f">ssc_data_set_matrix</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name, <a href="#sscapi_8h_aed2c6c08a4d87fc653895a27065b5c8d">ssc_number_t</a> &#X2217;pvalues, int nrows, int ncols)
SSCEXPORT void <a href="#sscapi_8h_a8f86dcefe1ddcf1b4190a4ee415d14f2">ssc_data_set_table</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name, <a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> table)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_a118454db6d4080a623bc176db005c7b1">ssc_data_get_string</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name)
SSCEXPORT <a href="#sscapi_8h_a8416be1f3d7e7d4457bf37e657277575">ssc_bool_t</a> <a href="#sscapi_8h_a2a815f31617dee3c96587fe2df6938ff">ssc_data_get_number</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name, <a href="#sscapi_8h_aed2c6c08a4d87fc653895a27065b5c8d">ssc_number_t</a> &#X2217;value)
SSCEXPORT <a href="#sscapi_8h_aed2c6c08a4d87fc653895a27065b5c8d">ssc_number_t</a> &#X2217; <a href="#sscapi_8h_a4fea1289c16bcd422f343cecfd9808de">ssc_data_get_array</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name, int &#X2217;length)
SSCEXPORT <a href="#sscapi_8h_aed2c6c08a4d87fc653895a27065b5c8d">ssc_number_t</a> &#X2217; <a href="#sscapi_8h_a5910932a763203c9c0f6d43776453f5e">ssc_data_get_matrix</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name, int &#X2217;nrows, int &#X2217;ncols)
SSCEXPORT <a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> <a href="#sscapi_8h_a9589098332e14ce8b9823e4ac8afdf22">ssc_data_get_table</a> (<a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, const char &#X2217;name)
SSCEXPORT <a href="#sscapi_8h_a0f778c7e3611dfc2ba01e5bd89979f80">ssc_entry_t</a> <a href="#sscapi_8h_acb6e7a1f9ac26d3160fc849754a38627">ssc_module_entry</a> (int index)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_a785b1e08e248478ee792ac945bd1eb31">ssc_entry_name</a> (<a href="#sscapi_8h_a0f778c7e3611dfc2ba01e5bd89979f80">ssc_entry_t</a> p_entry)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_a86977139c320479baf3b4762513a8f6d">ssc_entry_description</a> (<a href="#sscapi_8h_a0f778c7e3611dfc2ba01e5bd89979f80">ssc_entry_t</a> p_entry)
SSCEXPORT int <a href="#sscapi_8h_a449e4d53d00830b7b85a1e88a99f078f">ssc_entry_version</a> (<a href="#sscapi_8h_a0f778c7e3611dfc2ba01e5bd89979f80">ssc_entry_t</a> p_entry)
SSCEXPORT <a href="#sscapi_8h_adf8d62c898e485fc7440d3ed2fb0d87c">ssc_module_t</a> <a href="#sscapi_8h_a128141ac47daba53202b86a009e1cea7">ssc_module_create</a> (const char &#X2217;name)
SSCEXPORT void <a href="#sscapi_8h_a55fb17057398f14de0f7a3fcba9d328e">ssc_module_free</a> (<a href="#sscapi_8h_adf8d62c898e485fc7440d3ed2fb0d87c">ssc_module_t</a> p_mod)
SSCEXPORT const <a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> <a href="#sscapi_8h_acfb10163d7b9bea42b2e444c2a5544ac">ssc_module_var_info</a> (<a href="#sscapi_8h_adf8d62c898e485fc7440d3ed2fb0d87c">ssc_module_t</a> p_mod, int index)
SSCEXPORT int <a href="#sscapi_8h_a25c204af7a2c81d11d134a62702426b5">ssc_info_var_type</a> (<a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> p_inf)
SSCEXPORT int <a href="#sscapi_8h_ab2fde3d3031880da882aee086afc76b3">ssc_info_data_type</a> (<a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> p_inf)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_a92f71d2241b912330d2734ba63d6b85f">ssc_info_name</a> (<a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> p_inf)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_a04113d80460294539d935c04ca8d8f36">ssc_info_label</a> (<a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> p_inf)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_aafe4ecee010642fabc99b1591c0680f8">ssc_info_units</a> (<a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> p_inf)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_a6e13987c293cb1044d893dee334daa5b">ssc_info_meta</a> (<a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> p_inf)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_a988bfd5148b165f3f3fc9f9f0f021262">ssc_info_group</a> (<a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> p_inf)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_a9ef2812e6f2c9b4a650c5e729f5c5ef5">ssc_info_required</a> (<a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> p_inf)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_a1a5af0286399b099684fa0f09ec149cf">ssc_info_constraints</a> (<a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> p_inf)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_ab895b6deba0be468250fc84ff027ed73">ssc_info_uihint</a> (<a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> p_inf)
SSCEXPORT <a href="#sscapi_8h_a8416be1f3d7e7d4457bf37e657277575">ssc_bool_t</a> <a href="#sscapi_8h_a360e90bdd0738c494c7992f15467268d">ssc_module_exec_simple</a> (const char &#X2217;name, <a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_ae13b12f038c0c491cda6dfda90152abb">ssc_module_exec_simple_nothread</a> (const char &#X2217;name, <a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data)
SSCEXPORT <a href="#sscapi_8h_a8416be1f3d7e7d4457bf37e657277575">ssc_bool_t</a> <a href="#sscapi_8h_a76d8a523407f3c071a9cf22ad2935a41">ssc_module_exec</a> (<a href="#sscapi_8h_adf8d62c898e485fc7440d3ed2fb0d87c">ssc_module_t</a> p_mod, <a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data)
SSCEXPORT <a href="#sscapi_8h_a8416be1f3d7e7d4457bf37e657277575">ssc_bool_t</a> <a href="#sscapi_8h_a58968776ff9ba65e9ac1886a0bdcb8df">ssc_module_exec_with_handler</a> (<a href="#sscapi_8h_adf8d62c898e485fc7440d3ed2fb0d87c">ssc_module_t</a> p_mod, <a href="#sscapi_8h_a082e17260ab55ccb945bcabd4509f439">ssc_data_t</a> p_data, <a href="#sscapi_8h_a8416be1f3d7e7d4457bf37e657277575">ssc_bool_t</a>(&#X2217;pf_handler)(<a href="#sscapi_8h_adf8d62c898e485fc7440d3ed2fb0d87c">ssc_module_t</a>, <a href="#sscapi_8h_a64a6b436524349ccf0a77b56b2cf4e9d">ssc_handler_t</a>, int action, float f0, float f1, const char &#X2217;s0, const char &#X2217;s1, void &#X2217;user_data), void &#X2217;pf_user_data)
SSCEXPORT void <a href="#sscapi_8h_a3294f94eeae580dbf3aa58eacec0a41d">ssc_module_extproc_output</a> (<a href="#sscapi_8h_a64a6b436524349ccf0a77b56b2cf4e9d">ssc_handler_t</a> p_mod, const char &#X2217;output_line)
SSCEXPORT const char &#X2217; <a href="#sscapi_8h_a595854e4dc9d1e10e7a36eb1715b55dc">ssc_module_log</a> (<a href="#sscapi_8h_adf8d62c898e485fc7440d3ed2fb0d87c">ssc_module_t</a> p_mod, int index, int &#X2217;item_type, float &#X2217;time)
SSCEXPORT void <a href="#sscapi_8h_ad5d381c3a156fce3bd92f6810129d2b7">__ssc_segfault</a> ()
</p>
<!--TOC subsubsection id=sec46 Detailed Description-->
<h4 id="sec46" class="subsubsection">8.1.1&#XA0;&#XA0;Detailed Description</h4><!--SEC END --><p>
The SAM Simulation Core (SSC) is a general purpose simulation input/output framework that is cross-platform (Windows/MacOSX/Unix) and compatible with both 32-bit and 64-bit operating systems. Note
Be sure to use the correct library for your operating platform: ssc32 or ssc64. Opaque pointer types will be 4-byte pointer on 32-bit architectures, and 8-byte pointer on 64-bit architectures.</p><p>Shared libraries have the .dll file extension on Windows, .dylib on MacOSX, and .so on Linux/Unix.

Copyright
2012 National Renewable Energy Laboratory 

Authors
Aron Dobos, Steven Janzou 
</p>
<!--TOC subsubsection id=sec47 Typedef Documentation-->
<h4 id="sec47" class="subsubsection">8.1.2&#XA0;&#XA0;Typedef Documentation</h4><!--SEC END --><p>
<a id="sscapi_8h_a8416be1f3d7e7d4457bf37e657277575">sscapi.h@sscapi.h!ssc_bool_t@ssc_bool_t
ssc_bool_t@ssc_bool_t!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec48 ssc_bool_t-->
<h5 id="sec48" class="paragraph">typedef int <span style="font-weight:bold">ssc_bool_t</span></h5><!--SEC END --><p></a><a id="sscapi_8h_a8416be1f3d7e7d4457bf37e657277575"></a>
The boolean type used internally in SSC.</p><p>Zero values represent false; non-zero represents true. <a id="sscapi_8h_a082e17260ab55ccb945bcabd4509f439">sscapi.h@sscapi.h!ssc_data_t@ssc_data_t
ssc_data_t@ssc_data_t!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec49 ssc_data_t-->
<h5 id="sec49" class="paragraph">typedef void&#X2217; <span style="font-weight:bold">ssc_data_t</span></h5><!--SEC END --><p></a><a id="sscapi_8h_a082e17260ab55ccb945bcabd4509f439"></a>
An opaque reference to a structure that holds a collection of variables.</p><p>This structure can contain any number of variables referenced by name, and can hold strings, numbers, arrays, and matrices. Matrices are stored in row-major order, where the array size is nrows&#X2217;ncols, and the array index is calculated by r&#X2217;ncols+c.</p><p>An ssc_data_t object holds all input and output variables for a simulation. It does not distinguish between input, output, and inout variables - that is handled at the model context level.</p><p>For convenience, a ssc_data_t can be written to a file on disk, and later retrieved. <a id="sscapi_8h_a0f778c7e3611dfc2ba01e5bd89979f80">sscapi.h@sscapi.h!ssc_entry_t@ssc_entry_t
ssc_entry_t@ssc_entry_t!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec50 ssc_entry_t-->
<h5 id="sec50" class="paragraph">typedef void&#X2217; <span style="font-weight:bold">ssc_entry_t</span></h5><!--SEC END --><p></a><a id="sscapi_8h_a0f778c7e3611dfc2ba01e5bd89979f80"></a>
Returns information of all computation modules built into ssc. Example:</p><p>
<span style="color:black">int</span> i=0;
<a href="#sscapi_8h_a0f778c7e3611dfc2ba01e5bd89979f80">ssc_entry_t</a> p_entry;
<span style="color:black">while</span>( p_entry = <a href="#sscapi_8h_acb6e7a1f9ac26d3160fc849754a38627">ssc_module_entry</a>(i++) )
{
printf(<span style="color:black">"Compute Module &#X2019;</span>, <a href="#sscapi_8h_a785b1e08e248478ee792ac945bd1eb31">ssc_entry_name</a>(
p_entry), <a href="#sscapi_8h_a86977139c320479baf3b4762513a8f6d">ssc_entry_description</a>(p_entry));
}

The opaque data structure that stores information about a compute module. <a id="sscapi_8h_a64a6b436524349ccf0a77b56b2cf4e9d">sscapi.h@sscapi.h!ssc_handler_t@ssc_handler_t
ssc_handler_t@ssc_handler_t!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec51 ssc_handler_t-->
<h5 id="sec51" class="paragraph">typedef void&#X2217; <span style="font-weight:bold">ssc_handler_t</span></h5><!--SEC END --><p></a><a id="sscapi_8h_a64a6b436524349ccf0a77b56b2cf4e9d"></a>
An opaque pointer for transferring external executable output back to SSC <a id="sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">sscapi.h@sscapi.h!ssc_info_t@ssc_info_t
ssc_info_t@ssc_info_t!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec52 ssc_info_t-->
<h5 id="sec52" class="paragraph">typedef void&#X2217; <span style="font-weight:bold">ssc_info_t</span></h5><!--SEC END --><p></a><a id="sscapi_8h_aff18f3d1ec484009b88a779dcb69d456"></a>
An opaque reference to variable information. A compute module defines its input/output variables. <a id="sscapi_8h_adf8d62c898e485fc7440d3ed2fb0d87c">sscapi.h@sscapi.h!ssc_module_t@ssc_module_t
ssc_module_t@ssc_module_t!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec53 ssc_module_t-->
<h5 id="sec53" class="paragraph">typedef void&#X2217; <span style="font-weight:bold">ssc_module_t</span></h5><!--SEC END --><p></a><a id="sscapi_8h_adf8d62c898e485fc7440d3ed2fb0d87c"></a>
An opaque reference to a computation module.</p><p>Note
A computation module performs a transformation on a ssc_data_t. It usually is used to calculate output variables given a set of input variables, but it can also be used to change the values of variables defined as INOUT. Modules types have unique names, and store information about what input variables are required, what outputs can be expected, along with specific data type, unit, label, and meta information about each variable. 

<a id="sscapi_8h_aed2c6c08a4d87fc653895a27065b5c8d">sscapi.h@sscapi.h!ssc_number_t@ssc_number_t
ssc_number_t@ssc_number_t!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec54 ssc_number_t-->
<h5 id="sec54" class="paragraph">typedef float <span style="font-weight:bold">ssc_number_t</span></h5><!--SEC END --><p></a><a id="sscapi_8h_aed2c6c08a4d87fc653895a27065b5c8d"></a>
The numeric type used internally in SSC.</p><p>All numeric values are stored in this format. Do not change this without recompiling the library. </p>
<!--TOC subsubsection id=sec55 Function Documentation-->
<h4 id="sec55" class="subsubsection">8.1.3&#XA0;&#XA0;Function Documentation</h4><!--SEC END --><p>
<a id="sscapi_8h_ad5d381c3a156fce3bd92f6810129d2b7">sscapi.h@sscapi.h!__ssc_segfault@__ssc_segfault
__ssc_segfault@__ssc_segfault!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec56 __ssc_segfault-->
<h5 id="sec56" class="paragraph">SSCEXPORT void __ssc_segfault (



)</h5><!--SEC END --><p></a><a id="sscapi_8h_ad5d381c3a156fce3bd92f6810129d2b7"></a>
DO NOT CALL THIS FUNCTION: immediately causes a segmentation fault within the library. This is only useful for testing crash handling from an external application that is dynamically linked to the SSC library <a id="sscapi_8h_ab34ddddf0832ff80d36c08af415fcf61">sscapi.h@sscapi.h!ssc_build_info@ssc_build_info
ssc_build_info@ssc_build_info!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec57 ssc_build_info-->
<h5 id="sec57" class="paragraph">SSCEXPORT const char&#X2217; ssc_build_info (



)</h5><!--SEC END --><p></a><a id="sscapi_8h_ab34ddddf0832ff80d36c08af415fcf61"></a>
Returns an ASCII text string that lists the compiler, platform, build date/time and other information. Returns
Information about the build configuration of this particular SSC library binary. 

<a id="sscapi_8h_adc28c6035c08ce6f88d5e228b3d3cd25">sscapi.h@sscapi.h!ssc_data_clear@ssc_data_clear
ssc_data_clear@ssc_data_clear!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec58 ssc_data_clear-->
<h5 id="sec58" class="paragraph">SSCEXPORT void ssc_data_clear (

p_data

)</h5><!--SEC END --><p></a><a id="sscapi_8h_adc28c6035c08ce6f88d5e228b3d3cd25"></a>
Clears all of the variables in a data object. <a id="sscapi_8h_ac9f368730a0da3c79169cd6d3eef8f0b">sscapi.h@sscapi.h!ssc_data_create@ssc_data_create
ssc_data_create@ssc_data_create!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec59 ssc_data_create-->
<h5 id="sec59" class="paragraph">SSCEXPORT <span style="font-weight:bold">ssc_data_t</span> ssc_data_create (



)</h5><!--SEC END --><p></a><a id="sscapi_8h_ac9f368730a0da3c79169cd6d3eef8f0b"></a>
Creates a new data object in memory. A data object stores a table of named values, where each value can be of any SSC datatype. <a id="sscapi_8h_ad499cfe8696e1f704d968b50d3ab36b1">sscapi.h@sscapi.h!ssc_data_first@ssc_data_first
ssc_data_first@ssc_data_first!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec60 ssc_data_first-->
<h5 id="sec60" class="paragraph">SSCEXPORT const char&#X2217; ssc_data_first (

p_data

)</h5><!--SEC END --><p></a><a id="sscapi_8h_ad499cfe8696e1f704d968b50d3ab36b1"></a>
Returns the name of the first variable in the table, or 0 (NULL) if the data object is empty. <a id="sscapi_8h_acc9123254cfd9b1483a34a840ba66f3f">sscapi.h@sscapi.h!ssc_data_free@ssc_data_free
ssc_data_free@ssc_data_free!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec61 ssc_data_free-->
<h5 id="sec61" class="paragraph">SSCEXPORT void ssc_data_free (

p_data

)</h5><!--SEC END --><p></a><a id="sscapi_8h_acc9123254cfd9b1483a34a840ba66f3f"></a>
Frees the memory associated with a data object. <a id="sscapi_8h_a4fea1289c16bcd422f343cecfd9808de">sscapi.h@sscapi.h!ssc_data_get_array@ssc_data_get_array
ssc_data_get_array@ssc_data_get_array!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec62 ssc_data_get_array-->
<h5 id="sec62" class="paragraph">SSCEXPORT <span style="font-weight:bold">ssc_number_t</span>&#X2217; ssc_data_get_array (

p_data, 
name, 
length

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a4fea1289c16bcd422f343cecfd9808de"></a>
Returns the value of a <span style="font-style:italic">SSC_ARRAY</span> variable with the given name. <a id="sscapi_8h_a5910932a763203c9c0f6d43776453f5e">sscapi.h@sscapi.h!ssc_data_get_matrix@ssc_data_get_matrix
ssc_data_get_matrix@ssc_data_get_matrix!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec63 ssc_data_get_matrix-->
<h5 id="sec63" class="paragraph">SSCEXPORT <span style="font-weight:bold">ssc_number_t</span>&#X2217; ssc_data_get_matrix (

p_data, 
name, 
nrows, 
ncols

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a5910932a763203c9c0f6d43776453f5e"></a>
Returns the value of a <span style="font-style:italic">SSC_MATRIX</span> variable with the given name. Matrices are specified as a continuous array, in row-major order. Example: the matrix [[5,2,3],[9,1,4]] is stored as [5,2,3,9,1,4].
<a id="sscapi_8h_a2a815f31617dee3c96587fe2df6938ff">sscapi.h@sscapi.h!ssc_data_get_number@ssc_data_get_number
ssc_data_get_number@ssc_data_get_number!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec64 ssc_data_get_number-->
<h5 id="sec64" class="paragraph">SSCEXPORT <span style="font-weight:bold">ssc_bool_t</span> ssc_data_get_number (

p_data, 
name, 
value

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a2a815f31617dee3c96587fe2df6938ff"></a>
Returns the value of a <span style="font-style:italic">SSC_NUMBER</span> variable with the given name. <a id="sscapi_8h_a118454db6d4080a623bc176db005c7b1">sscapi.h@sscapi.h!ssc_data_get_string@ssc_data_get_string
ssc_data_get_string@ssc_data_get_string!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec65 ssc_data_get_string-->
<h5 id="sec65" class="paragraph">SSCEXPORT const char&#X2217; ssc_data_get_string (

p_data, 
name

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a118454db6d4080a623bc176db005c7b1"></a>
Note
Retrieving variable values. These functions return internal references to memory, and the returned string, array, matrix, and tables should not be freed by the user. Returns the value of a <span style="font-style:italic">SSC_STRING</span> variable with the given name. 

<a id="sscapi_8h_a9589098332e14ce8b9823e4ac8afdf22">sscapi.h@sscapi.h!ssc_data_get_table@ssc_data_get_table
ssc_data_get_table@ssc_data_get_table!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec66 ssc_data_get_table-->
<h5 id="sec66" class="paragraph">SSCEXPORT <span style="font-weight:bold">ssc_data_t</span> ssc_data_get_table (

p_data, 
name

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a9589098332e14ce8b9823e4ac8afdf22"></a>
Returns the value of a <span style="font-style:italic">SSC_TABLE</span> variable with the given name. <a id="sscapi_8h_a56b8a556bfe81c4f65fa2f3c41b5db31">sscapi.h@sscapi.h!ssc_data_next@ssc_data_next
ssc_data_next@ssc_data_next!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec67 ssc_data_next-->
<h5 id="sec67" class="paragraph">SSCEXPORT const char&#X2217; ssc_data_next (

p_data

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a56b8a556bfe81c4f65fa2f3c41b5db31"></a>
Returns the name of the next variable in the table, or 0 (NULL) if there are no more variables in the table. ssc_data_first must be called first. <a id="sscapi_8h_ab6598d213b423fe7c3b85071119f4cb0">sscapi.h@sscapi.h!ssc_data_query@ssc_data_query
ssc_data_query@ssc_data_query!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec68 ssc_data_query-->
<h5 id="sec68" class="paragraph">SSCEXPORT int ssc_data_query (

p_data, 
name

)</h5><!--SEC END --><p></a><a id="sscapi_8h_ab6598d213b423fe7c3b85071119f4cb0"></a>
Querys the data object for the data type of the variable with the specified name Returns
data type, or SSC_INVALID if that variable was not found. 

<a id="sscapi_8h_a2a65f966686e481fc4f63803a968f3d4">sscapi.h@sscapi.h!ssc_data_set_array@ssc_data_set_array
ssc_data_set_array@ssc_data_set_array!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec69 ssc_data_set_array-->
<h5 id="sec69" class="paragraph">SSCEXPORT void ssc_data_set_array (

p_data, 
name, 
pvalues, 
length

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a2a65f966686e481fc4f63803a968f3d4"></a>
Assigns value of type <span style="font-style:italic">SSC_ARRAY</span> <a id="sscapi_8h_ae823313deeeb06e37ddf6dfaab17190f">sscapi.h@sscapi.h!ssc_data_set_matrix@ssc_data_set_matrix
ssc_data_set_matrix@ssc_data_set_matrix!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec70 ssc_data_set_matrix-->
<h5 id="sec70" class="paragraph">SSCEXPORT void ssc_data_set_matrix (

p_data, 
name, 
pvalues, 
nrows, 
ncols

)</h5><!--SEC END --><p></a><a id="sscapi_8h_ae823313deeeb06e37ddf6dfaab17190f"></a>
Assigns value of type <span style="font-style:italic">SSC_MATRIX</span> Matrices are specified as a continuous array, in row-major order. Example: the matrix [[5,2,3],[9,1,4]] is stored as [5,2,3,9,1,4].
<a id="sscapi_8h_a42e160996afdef0ab4b3c085c253e364">sscapi.h@sscapi.h!ssc_data_set_number@ssc_data_set_number
ssc_data_set_number@ssc_data_set_number!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec71 ssc_data_set_number-->
<h5 id="sec71" class="paragraph">SSCEXPORT void ssc_data_set_number (

p_data, 
name, 
value

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a42e160996afdef0ab4b3c085c253e364"></a>
Assigns value of type <span style="font-style:italic">SSC_NUMBER</span> <a id="sscapi_8h_aa660663a8343fb2ddb7f7aa1d6a93205">sscapi.h@sscapi.h!ssc_data_set_string@ssc_data_set_string
ssc_data_set_string@ssc_data_set_string!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec72 ssc_data_set_string-->
<h5 id="sec72" class="paragraph">SSCEXPORT void ssc_data_set_string (

p_data, 
name, 
value

)</h5><!--SEC END --><p></a><a id="sscapi_8h_aa660663a8343fb2ddb7f7aa1d6a93205"></a></p><p>
<span style="color:black">// Iterate over all variables in a data object</span>
<span style="color:black">const</span> <span style="color:black">char</span> *key = <a href="#sscapi_8h_ad499cfe8696e1f704d968b50d3ab36b1">ssc_data_first</a>( my_data );
<span style="color:black">while</span> (key != 0)
{
<span style="color:black">// do something, like query the type</span>
<span style="color:black">int</span> type = <a href="#sscapi_8h_ab6598d213b423fe7c3b85071119f4cb0">ssc_data_query</a>( my_data, key );</p><p>key = <a href="#sscapi_8h_a56b8a556bfe81c4f65fa2f3c41b5db31">ssc_data_next</a>( my_data );
}

Note
Assigning variable values. These functions do not take ownership of the data pointeres for arrays, matrices, and tables. A deep copy is made into the internal SSC engine. You must remember to free the table that you create to pass into <a href="#sscapi_8h_a8f86dcefe1ddcf1b4190a4ee415d14f2">ssc_data_set_table( )</a> for example. Assigns value of type <span style="font-style:italic">SSC_STRING</span> 

<a id="sscapi_8h_a8f86dcefe1ddcf1b4190a4ee415d14f2">sscapi.h@sscapi.h!ssc_data_set_table@ssc_data_set_table
ssc_data_set_table@ssc_data_set_table!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec73 ssc_data_set_table-->
<h5 id="sec73" class="paragraph">SSCEXPORT void ssc_data_set_table (

p_data, 
name, 
table

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a8f86dcefe1ddcf1b4190a4ee415d14f2"></a>
Assigns value of type <span style="font-style:italic">SSC_TABLE</span>. <a id="sscapi_8h_a5044cd17abb621f4549c6fd0aab77277">sscapi.h@sscapi.h!ssc_data_unassign@ssc_data_unassign
ssc_data_unassign@ssc_data_unassign!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec74 ssc_data_unassign-->
<h5 id="sec74" class="paragraph">SSCEXPORT void ssc_data_unassign (

p_data, 
name

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a5044cd17abb621f4549c6fd0aab77277"></a>
Unassigns the variable with the specified name. <a id="sscapi_8h_a86977139c320479baf3b4762513a8f6d">sscapi.h@sscapi.h!ssc_entry_description@ssc_entry_description
ssc_entry_description@ssc_entry_description!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec75 ssc_entry_description-->
<h5 id="sec75" class="paragraph">SSCEXPORT const char&#X2217; ssc_entry_description (

p_entry

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a86977139c320479baf3b4762513a8f6d"></a>
Returns a short text description of a compute module. <a id="sscapi_8h_a785b1e08e248478ee792ac945bd1eb31">sscapi.h@sscapi.h!ssc_entry_name@ssc_entry_name
ssc_entry_name@ssc_entry_name!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec76 ssc_entry_name-->
<h5 id="sec76" class="paragraph">SSCEXPORT const char&#X2217; ssc_entry_name (

p_entry

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a785b1e08e248478ee792ac945bd1eb31"></a>
Returns the name of a compute module. This is the name that is used to create a new compute module. <a id="sscapi_8h_a449e4d53d00830b7b85a1e88a99f078f">sscapi.h@sscapi.h!ssc_entry_version@ssc_entry_version
ssc_entry_version@ssc_entry_version!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec77 ssc_entry_version-->
<h5 id="sec77" class="paragraph">SSCEXPORT int ssc_entry_version (

p_entry

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a449e4d53d00830b7b85a1e88a99f078f"></a>
Returns version information about a compute module. <a id="sscapi_8h_a1a5af0286399b099684fa0f09ec149cf">sscapi.h@sscapi.h!ssc_info_constraints@ssc_info_constraints
ssc_info_constraints@ssc_info_constraints!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec78 ssc_info_constraints-->
<h5 id="sec78" class="paragraph">SSCEXPORT const char&#X2217; ssc_info_constraints (

p_inf

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a1a5af0286399b099684fa0f09ec149cf"></a>
Returns constraints on the values accepted. For example, MIN, MAX, BOOLEAN, INTEGER, POSITIVE are possible constraints. <a id="sscapi_8h_ab2fde3d3031880da882aee086afc76b3">sscapi.h@sscapi.h!ssc_info_data_type@ssc_info_data_type
ssc_info_data_type@ssc_info_data_type!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec79 ssc_info_data_type-->
<h5 id="sec79" class="paragraph">SSCEXPORT int ssc_info_data_type (

p_inf

)</h5><!--SEC END --><p></a><a id="sscapi_8h_ab2fde3d3031880da882aee086afc76b3"></a>
Returns the data type of a variable: SSC_STRING, SSC_NUMBER, SSC_ARRAY, SSC_MATRIX, SSC_TABLE <a id="sscapi_8h_a988bfd5148b165f3f3fc9f9f0f021262">sscapi.h@sscapi.h!ssc_info_group@ssc_info_group
ssc_info_group@ssc_info_group!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec80 ssc_info_group-->
<h5 id="sec80" class="paragraph">SSCEXPORT const char&#X2217; ssc_info_group (

p_inf

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a988bfd5148b165f3f3fc9f9f0f021262"></a>
Returns any grouping information. Variables can be assigned to groups for presentation to the user, for example <a id="sscapi_8h_a04113d80460294539d935c04ca8d8f36">sscapi.h@sscapi.h!ssc_info_label@ssc_info_label
ssc_info_label@ssc_info_label!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec81 ssc_info_label-->
<h5 id="sec81" class="paragraph">SSCEXPORT const char&#X2217; ssc_info_label (

p_inf

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a04113d80460294539d935c04ca8d8f36"></a>
Returns the short label description of the variable <a id="sscapi_8h_a6e13987c293cb1044d893dee334daa5b">sscapi.h@sscapi.h!ssc_info_meta@ssc_info_meta
ssc_info_meta@ssc_info_meta!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec82 ssc_info_meta-->
<h5 id="sec82" class="paragraph">SSCEXPORT const char&#X2217; ssc_info_meta (

p_inf

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a6e13987c293cb1044d893dee334daa5b"></a>
Returns any extra information about a variable <a id="sscapi_8h_a92f71d2241b912330d2734ba63d6b85f">sscapi.h@sscapi.h!ssc_info_name@ssc_info_name
ssc_info_name@ssc_info_name!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec83 ssc_info_name-->
<h5 id="sec83" class="paragraph">SSCEXPORT const char&#X2217; ssc_info_name (

p_inf

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a92f71d2241b912330d2734ba63d6b85f"></a>
Returns the name of a variable <a id="sscapi_8h_a9ef2812e6f2c9b4a650c5e729f5c5ef5">sscapi.h@sscapi.h!ssc_info_required@ssc_info_required
ssc_info_required@ssc_info_required!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec84 ssc_info_required-->
<h5 id="sec84" class="paragraph">SSCEXPORT const char&#X2217; ssc_info_required (

p_inf

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a9ef2812e6f2c9b4a650c5e729f5c5ef5"></a>
Returns information about whether a variable is required to be assigned for a compute module to run. It may alternatively be given a default value, specified as &#X2019;?=</p><p>&#X2019;. <a id="sscapi_8h_ab895b6deba0be468250fc84ff027ed73">sscapi.h@sscapi.h!ssc_info_uihint@ssc_info_uihint
ssc_info_uihint@ssc_info_uihint!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec85 ssc_info_uihint-->
<h5 id="sec85" class="paragraph">SSCEXPORT const char&#X2217; ssc_info_uihint (

p_inf

)</h5><!--SEC END --><p></a><a id="sscapi_8h_ab895b6deba0be468250fc84ff027ed73"></a>
Returns additional information for use in a target application about how to show the variable to the user. Not used currently. <a id="sscapi_8h_aafe4ecee010642fabc99b1591c0680f8">sscapi.h@sscapi.h!ssc_info_units@ssc_info_units
ssc_info_units@ssc_info_units!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec86 ssc_info_units-->
<h5 id="sec86" class="paragraph">SSCEXPORT const char&#X2217; ssc_info_units (

p_inf

)</h5><!--SEC END --><p></a><a id="sscapi_8h_aafe4ecee010642fabc99b1591c0680f8"></a>
Returns the units of the values for the variable <a id="sscapi_8h_a25c204af7a2c81d11d134a62702426b5">sscapi.h@sscapi.h!ssc_info_var_type@ssc_info_var_type
ssc_info_var_type@ssc_info_var_type!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec87 ssc_info_var_type-->
<h5 id="sec87" class="paragraph">SSCEXPORT int ssc_info_var_type (

p_inf

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a25c204af7a2c81d11d134a62702426b5"></a>
Returns variable type information: SSC_INPUT, SSC_OUTPUT, or SSC_INOUT <a id="sscapi_8h_a128141ac47daba53202b86a009e1cea7">sscapi.h@sscapi.h!ssc_module_create@ssc_module_create
ssc_module_create@ssc_module_create!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec88 ssc_module_create-->
<h5 id="sec88" class="paragraph">SSCEXPORT <span style="font-weight:bold">ssc_module_t</span> ssc_module_create (

name

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a128141ac47daba53202b86a009e1cea7"></a>
Creates an instance of a compute module with the given name. Returns
0 (NULL) if invalid name given and the module could not be created 

<a id="sscapi_8h_acb6e7a1f9ac26d3160fc849754a38627">sscapi.h@sscapi.h!ssc_module_entry@ssc_module_entry
ssc_module_entry@ssc_module_entry!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec89 ssc_module_entry-->
<h5 id="sec89" class="paragraph">SSCEXPORT <span style="font-weight:bold">ssc_entry_t</span> ssc_module_entry (

index

)</h5><!--SEC END --><p></a><a id="sscapi_8h_acb6e7a1f9ac26d3160fc849754a38627"></a>
Returns compute module information for the i-th module in the SSC library. Returns
0 (NULL) for an invalid index. 

<a id="sscapi_8h_a76d8a523407f3c071a9cf22ad2935a41">sscapi.h@sscapi.h!ssc_module_exec@ssc_module_exec
ssc_module_exec@ssc_module_exec!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec90 ssc_module_exec-->
<h5 id="sec90" class="paragraph">SSCEXPORT <span style="font-weight:bold">ssc_bool_t</span> ssc_module_exec (

p_mod, 
p_data

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a76d8a523407f3c071a9cf22ad2935a41"></a>
Runs a configured computation module over the specified data set. Returns 1 or 0. Detailed notices, warnings, and errors can be retrieved either via a request_handler callback function, or using the ssc_module_message function. <a id="sscapi_8h_a360e90bdd0738c494c7992f15467268d">sscapi.h@sscapi.h!ssc_module_exec_simple@ssc_module_exec_simple
ssc_module_exec_simple@ssc_module_exec_simple!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec91 ssc_module_exec_simple-->
<h5 id="sec91" class="paragraph">SSCEXPORT <span style="font-weight:bold">ssc_bool_t</span> ssc_module_exec_simple (

name, 
p_data

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a360e90bdd0738c494c7992f15467268d"></a>
The simplest way to run a computation module over a data set. Simply specify the name of the module, and a data set. If the whole process succeeded, the function returns 1, otherwise 0. No error messages are available. This function can be thread-safe, depending on the computation module used. If the computation module requires the execution of external binary executables, it is not thread-safe. However, simpler implementations that do all calculations internally are probably thread-safe. Unfortunately there is no standard way to report the thread-safety of a particular computation module. <a id="sscapi_8h_ae13b12f038c0c491cda6dfda90152abb">sscapi.h@sscapi.h!ssc_module_exec_simple_nothread@ssc_module_exec_simple_nothread
ssc_module_exec_simple_nothread@ssc_module_exec_simple_nothread!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec92 ssc_module_exec_simple_nothread-->
<h5 id="sec92" class="paragraph">SSCEXPORT const char&#X2217; ssc_module_exec_simple_nothread (

name, 
p_data

)</h5><!--SEC END --><p></a><a id="sscapi_8h_ae13b12f038c0c491cda6dfda90152abb"></a>
Another very simple way to run a computation module over a data set. The function returns NULL on success. If something went wrong, the first error message is returned. Because the returned string references a common internal data container, this function is never thread-safe. <a id="sscapi_8h_a58968776ff9ba65e9ac1886a0bdcb8df">sscapi.h@sscapi.h!ssc_module_exec_with_handler@ssc_module_exec_with_handler
ssc_module_exec_with_handler@ssc_module_exec_with_handler!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec93 ssc_module_exec_with_handler-->
<h5 id="sec93" class="paragraph">SSCEXPORT <span style="font-weight:bold">ssc_bool_t</span> ssc_module_exec_with_handler (

p_mod, 
p_data, 
pf_handler, 
pf_user_data

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a58968776ff9ba65e9ac1886a0bdcb8df"></a>
A full-featured way to run a compute module with a callback function to handle custom logging, progress updates, and external binary execute requests <a id="sscapi_8h_a3294f94eeae580dbf3aa58eacec0a41d">sscapi.h@sscapi.h!ssc_module_extproc_output@ssc_module_extproc_output
ssc_module_extproc_output@ssc_module_extproc_output!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec94 ssc_module_extproc_output-->
<h5 id="sec94" class="paragraph">SSCEXPORT void ssc_module_extproc_output (

p_mod, 
output_line

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a3294f94eeae580dbf3aa58eacec0a41d"></a>
Helper function to be called from within a scc_exec_with_handler callback function to log binary output messages <a id="sscapi_8h_a55fb17057398f14de0f7a3fcba9d328e">sscapi.h@sscapi.h!ssc_module_free@ssc_module_free
ssc_module_free@ssc_module_free!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec95 ssc_module_free-->
<h5 id="sec95" class="paragraph">SSCEXPORT void ssc_module_free (

p_mod

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a55fb17057398f14de0f7a3fcba9d328e"></a>
Releases an instance of a compute module created with ssc_module_create <a id="sscapi_8h_a595854e4dc9d1e10e7a36eb1715b55dc">sscapi.h@sscapi.h!ssc_module_log@ssc_module_log
ssc_module_log@ssc_module_log!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec96 ssc_module_log-->
<h5 id="sec96" class="paragraph">SSCEXPORT const char&#X2217; ssc_module_log (

p_mod, 
index, 
item_type, 
time

)</h5><!--SEC END --><p></a><a id="sscapi_8h_a595854e4dc9d1e10e7a36eb1715b55dc"></a>
Retrive notices, warnings, and error messages from the simulation <a id="sscapi_8h_acfb10163d7b9bea42b2e444c2a5544ac">sscapi.h@sscapi.h!ssc_module_var_info@ssc_module_var_info
ssc_module_var_info@ssc_module_var_info!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec97 ssc_module_var_info-->
<h5 id="sec97" class="paragraph">SSCEXPORT const <span style="font-weight:bold">ssc_info_t</span> ssc_module_var_info (

p_mod, 
index

)</h5><!--SEC END --><p></a><a id="sscapi_8h_acfb10163d7b9bea42b2e444c2a5544ac"></a>
Returns references to variable info objects. Example for a previously created &#X2019;p_mod&#X2019; object:</p><p>
<span style="color:black">int</span> i=0;
<span style="color:black">const</span> <a href="#sscapi_8h_aff18f3d1ec484009b88a779dcb69d456">ssc_info_t</a> p_inf = NULL;
<span style="color:black">while</span> ( p_inf = <a href="#sscapi_8h_acfb10163d7b9bea42b2e444c2a5544ac">ssc_module_var_info</a>( p_mod, i++ ) )
{
<span style="color:black">int</span> var_type = <a href="#sscapi_8h_a25c204af7a2c81d11d134a62702426b5">ssc_info_var_type</a>( p_inf ); <span style="color:black">
// SSC_INPUT, SSC_OUTPUT, SSC_INOUT</span>
<span style="color:black">int</span> data_type = <a href="#sscapi_8h_ab2fde3d3031880da882aee086afc76b3">ssc_info_data_type</a>( p_inf ); <span style="color:black">
// SSC_STRING, SSC_NUMBER, SSC_ARRAY, SSC_MATRIX</span></p><p><span style="color:black">const</span> <span style="color:black">char</span> *name = <a href="#sscapi_8h_a92f71d2241b912330d2734ba63d6b85f">ssc_info_name</a>( p_inf );
<span style="color:black">const</span> <span style="color:black">char</span> *label = <a href="#sscapi_8h_a04113d80460294539d935c04ca8d8f36">ssc_info_label</a>( p_inf );
<span style="color:black">const</span> <span style="color:black">char</span> *units = <a href="#sscapi_8h_aafe4ecee010642fabc99b1591c0680f8">ssc_info_units</a>( p_inf );
<span style="color:black">const</span> <span style="color:black">char</span> *meta = <a href="#sscapi_8h_a6e13987c293cb1044d893dee334daa5b">ssc_info_meta</a>( p_inf );
<span style="color:black">const</span> <span style="color:black">char</span> *group = <a href="#sscapi_8h_a988bfd5148b165f3f3fc9f9f0f021262">ssc_info_group</a>( p_inf );
}
</p><p>Returns
Returns NULL for invalid index.

Note
Note that the ssc_info_&#X2217; functions that return strings may return NULL if the computation module has not specified a value, i.e. no units or no grouping name. 

<a id="sscapi_8h_a4460dd3f2316afa8a766769445e9fcd6">sscapi.h@sscapi.h!ssc_version@ssc_version
ssc_version@ssc_version!sscapi.h@sscapi.h
</p><!--TOC paragraph id=sec98 ssc_version-->
<h5 id="sec98" class="paragraph">SSCEXPORT int ssc_version (



)</h5><!--SEC END --><p></a><a id="sscapi_8h_a4460dd3f2316afa8a766769445e9fcd6"></a>
Returns the library version. Version numbers start at 1. Returns
SSC version number. 

</p><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</em><a href="http://hevea.inria.fr/index.html"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a><em>.</em></blockquote></body>
</html>
